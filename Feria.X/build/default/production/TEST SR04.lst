CCS PCM C Compiler, Version 5.015, 5967               22-ago.-24 11:25

               Filename:   H:\Mi unidad\Feria 2024\MPLAB\Feria.X\build\default\production\TEST SR04.lst

               ROM used:   1033 words (13%)
                           Largest free fragment is 2048
               RAM used:   27 (7%) at main() level
                           52 (14%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   378
0003:  NOP
.................... #include<16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
0004:  DATA C4,32
0005:  DATA EC,30
0006:  DATA 6E,3A
0007:  DATA 65,1D
0008:  DATA A0,12
0009:  DATA 2E,19
000A:  DATA 66,05
000B:  DATA 00,00
000C:  DATA C4,32
000D:  DATA F2,32
000E:  DATA 63,34
000F:  DATA 61,1D
0010:  DATA A0,12
0011:  DATA 2E,19
0012:  DATA 66,05
0013:  DATA 00,01
0014:  DATA 49,3D
0015:  DATA F1,3A
0016:  DATA E9,32
0017:  DATA 72,32
0018:  DATA 61,1D
0019:  DATA A0,12
001A:  DATA 2E,19
001B:  DATA 66,05
001C:  DATA 0A,05
001D:  DATA 0A,00
001E:  CLRF   78
001F:  CLRF   79
0020:  CLRF   77
0021:  CLRF   7A
0022:  MOVF   38,W
0023:  BTFSS  03.2
0024:  GOTO   028
0025:  MOVF   37,W
0026:  BTFSC  03.2
0027:  GOTO   042
0028:  MOVLW  10
0029:  MOVWF  39
002A:  BCF    03.0
002B:  RLF    35,F
002C:  RLF    36,F
002D:  RLF    77,F
002E:  RLF    7A,F
002F:  MOVF   38,W
0030:  SUBWF  7A,W
0031:  BTFSS  03.2
0032:  GOTO   035
0033:  MOVF   37,W
0034:  SUBWF  77,W
0035:  BTFSS  03.0
0036:  GOTO   03E
0037:  MOVF   37,W
0038:  SUBWF  77,F
0039:  BTFSS  03.0
003A:  DECF   7A,F
003B:  MOVF   38,W
003C:  SUBWF  7A,F
003D:  BSF    03.0
003E:  RLF    78,F
003F:  RLF    79,F
0040:  DECFSZ 39,F
0041:  GOTO   02A
0042:  RETURN
0043:  MOVLW  8E
0044:  MOVWF  77
0045:  MOVF   36,W
0046:  MOVWF  78
0047:  MOVF   35,W
0048:  MOVWF  79
0049:  CLRF   7A
004A:  MOVF   78,F
004B:  BTFSS  03.2
004C:  GOTO   057
004D:  MOVF   79,W
004E:  MOVWF  78
004F:  CLRF   79
0050:  MOVLW  08
0051:  SUBWF  77,F
0052:  MOVF   78,F
0053:  BTFSS  03.2
0054:  GOTO   057
0055:  CLRF   77
0056:  GOTO   05F
0057:  BCF    03.0
0058:  BTFSC  78.7
0059:  GOTO   05E
005A:  RLF    79,F
005B:  RLF    78,F
005C:  DECF   77,F
005D:  GOTO   057
005E:  BCF    78.7
005F:  RETURN
*
0162:  MOVF   0B,W
0163:  MOVWF  36
0164:  BCF    0B.7
0165:  BSF    03.5
0166:  BSF    03.6
0167:  BSF    0C.7
0168:  BSF    0C.0
0169:  NOP
016A:  NOP
016B:  BCF    03.5
016C:  BCF    03.6
016D:  BTFSC  36.7
016E:  BSF    0B.7
016F:  BTFSC  03.0
0170:  GOTO   19A
0171:  BSF    03.6
0172:  MOVF   0C,W
0173:  ANDLW  7F
0174:  BCF    03.6
0175:  MOVWF  36
0176:  BSF    03.6
0177:  MOVF   0D,W
0178:  BCF    03.6
0179:  MOVWF  37
017A:  BSF    03.6
017B:  MOVF   0F,W
017C:  BCF    03.6
017D:  MOVWF  38
017E:  MOVF   36,W
017F:  BTFSS  0C.4
0180:  GOTO   17F
0181:  MOVWF  19
0182:  MOVF   37,W
0183:  BSF    03.6
0184:  MOVWF  0D
0185:  BCF    03.6
0186:  MOVF   38,W
0187:  BSF    03.6
0188:  MOVWF  0F
0189:  BCF    03.6
018A:  MOVF   0B,W
018B:  MOVWF  39
018C:  BCF    0B.7
018D:  BSF    03.5
018E:  BSF    03.6
018F:  BSF    0C.7
0190:  BSF    0C.0
0191:  NOP
0192:  NOP
0193:  BCF    03.5
0194:  BCF    03.6
0195:  BTFSC  39.7
0196:  BSF    0B.7
0197:  DECFSZ 35,F
0198:  GOTO   19A
0199:  GOTO   1BA
019A:  BSF    03.6
019B:  RLF    0C,W
019C:  RLF    0E,W
019D:  ANDLW  7F
019E:  BCF    03.6
019F:  MOVWF  36
01A0:  BSF    03.6
01A1:  MOVF   0D,W
01A2:  BCF    03.6
01A3:  MOVWF  37
01A4:  BSF    03.6
01A5:  MOVF   0F,W
01A6:  BCF    03.6
01A7:  MOVWF  38
01A8:  MOVF   36,W
01A9:  BTFSS  0C.4
01AA:  GOTO   1A9
01AB:  MOVWF  19
01AC:  MOVF   37,W
01AD:  BSF    03.6
01AE:  MOVWF  0D
01AF:  BCF    03.6
01B0:  MOVF   38,W
01B1:  BSF    03.6
01B2:  MOVWF  0F
01B3:  INCF   0D,F
01B4:  BTFSC  03.2
01B5:  INCF   0F,F
01B6:  BCF    03.0
01B7:  BCF    03.6
01B8:  DECFSZ 35,F
01B9:  GOTO   162
01BA:  RETURN
01BB:  BTFSC  03.1
01BC:  GOTO   1C0
01BD:  MOVLW  4A
01BE:  MOVWF  04
01BF:  BCF    03.7
01C0:  CLRF   77
01C1:  CLRF   78
01C2:  CLRF   79
01C3:  CLRF   7A
01C4:  CLRF   4A
01C5:  CLRF   4B
01C6:  CLRF   4C
01C7:  CLRF   4D
01C8:  MOVF   49,W
01C9:  IORWF  48,W
01CA:  IORWF  47,W
01CB:  IORWF  46,W
01CC:  BTFSC  03.2
01CD:  GOTO   1FE
01CE:  MOVLW  20
01CF:  MOVWF  4E
01D0:  BCF    03.0
01D1:  RLF    42,F
01D2:  RLF    43,F
01D3:  RLF    44,F
01D4:  RLF    45,F
01D5:  RLF    4A,F
01D6:  RLF    4B,F
01D7:  RLF    4C,F
01D8:  RLF    4D,F
01D9:  MOVF   49,W
01DA:  SUBWF  4D,W
01DB:  BTFSS  03.2
01DC:  GOTO   1E7
01DD:  MOVF   48,W
01DE:  SUBWF  4C,W
01DF:  BTFSS  03.2
01E0:  GOTO   1E7
01E1:  MOVF   47,W
01E2:  SUBWF  4B,W
01E3:  BTFSS  03.2
01E4:  GOTO   1E7
01E5:  MOVF   46,W
01E6:  SUBWF  4A,W
01E7:  BTFSS  03.0
01E8:  GOTO   1F8
01E9:  MOVF   46,W
01EA:  SUBWF  4A,F
01EB:  MOVF   47,W
01EC:  BTFSS  03.0
01ED:  INCFSZ 47,W
01EE:  SUBWF  4B,F
01EF:  MOVF   48,W
01F0:  BTFSS  03.0
01F1:  INCFSZ 48,W
01F2:  SUBWF  4C,F
01F3:  MOVF   49,W
01F4:  BTFSS  03.0
01F5:  INCFSZ 49,W
01F6:  SUBWF  4D,F
01F7:  BSF    03.0
01F8:  RLF    77,F
01F9:  RLF    78,F
01FA:  RLF    79,F
01FB:  RLF    7A,F
01FC:  DECFSZ 4E,F
01FD:  GOTO   1D0
01FE:  MOVF   4A,W
01FF:  MOVWF  00
0200:  INCF   04,F
0201:  MOVF   4B,W
0202:  MOVWF  00
0203:  INCF   04,F
0204:  MOVF   4C,W
0205:  MOVWF  00
0206:  INCF   04,F
0207:  MOVF   4D,W
0208:  MOVWF  00
0209:  RETURN
020A:  MOVF   04,W
020B:  MOVWF  3A
020C:  MOVF   39,W
020D:  MOVWF  3C
020E:  BTFSC  03.2
020F:  GOTO   29C
0210:  MOVF   38,W
0211:  MOVWF  45
0212:  MOVF   37,W
0213:  MOVWF  44
0214:  MOVF   36,W
0215:  MOVWF  43
0216:  MOVF   35,W
0217:  MOVWF  42
0218:  CLRF   49
0219:  CLRF   48
021A:  MOVLW  20
021B:  MOVWF  47
021C:  MOVLW  82
021D:  MOVWF  46
021E:  MOVF   42,W
021F:  BTFSC  03.2
0220:  GOTO   28E
0221:  MOVWF  4A
0222:  MOVF   46,W
0223:  BTFSC  03.2
0224:  GOTO   28E
0225:  ADDWF  4A,F
0226:  BTFSC  03.0
0227:  GOTO   22F
0228:  MOVLW  7F
0229:  SUBWF  4A,F
022A:  BTFSS  03.0
022B:  GOTO   28E
022C:  BTFSC  03.2
022D:  GOTO   28E
022E:  GOTO   233
022F:  MOVLW  81
0230:  ADDWF  4A,F
0231:  BTFSC  03.0
0232:  GOTO   28E
0233:  MOVF   4A,W
0234:  MOVWF  77
0235:  CLRF   78
0236:  CLRF   79
0237:  CLRF   7A
0238:  MOVF   43,W
0239:  MOVWF  4E
023A:  BSF    4E.7
023B:  MOVF   44,W
023C:  MOVWF  4D
023D:  MOVF   45,W
023E:  MOVWF  4C
023F:  MOVLW  18
0240:  MOVWF  4A
0241:  CLRF   4B
0242:  BTFSS  4C.0
0243:  GOTO   25C
0244:  MOVF   49,W
0245:  ADDWF  7A,F
0246:  BTFSS  03.0
0247:  GOTO   24E
0248:  INCF   79,F
0249:  BTFSS  03.2
024A:  GOTO   24E
024B:  INCF   78,F
024C:  BTFSC  03.2
024D:  BSF    4B.7
024E:  MOVF   48,W
024F:  ADDWF  79,F
0250:  BTFSS  03.0
0251:  GOTO   255
0252:  INCF   78,F
0253:  BTFSC  03.2
0254:  BSF    4B.7
0255:  MOVF   47,W
0256:  MOVWF  44
0257:  BSF    44.7
0258:  MOVF   44,W
0259:  ADDWF  78,F
025A:  BTFSC  03.0
025B:  BSF    4B.7
025C:  RLF    4B,F
025D:  RRF    78,F
025E:  RRF    79,F
025F:  RRF    7A,F
0260:  RRF    4E,F
0261:  RRF    4D,F
0262:  RRF    4C,F
0263:  BCF    03.0
0264:  DECFSZ 4A,F
0265:  GOTO   241
0266:  MOVLW  01
0267:  ADDWF  77,F
0268:  BTFSC  03.0
0269:  GOTO   28E
026A:  BTFSC  78.7
026B:  GOTO   273
026C:  RLF    4E,F
026D:  RLF    7A,F
026E:  RLF    79,F
026F:  RLF    78,F
0270:  DECF   77,F
0271:  BTFSC  03.2
0272:  GOTO   28E
0273:  BTFSS  4E.7
0274:  GOTO   284
0275:  INCF   7A,F
0276:  BTFSS  03.2
0277:  GOTO   284
0278:  INCF   79,F
0279:  BTFSS  03.2
027A:  GOTO   284
027B:  INCF   78,F
027C:  BTFSS  03.2
027D:  GOTO   284
027E:  RRF    78,F
027F:  RRF    79,F
0280:  RRF    7A,F
0281:  INCF   77,F
0282:  BTFSC  03.2
0283:  GOTO   28E
0284:  MOVF   43,W
0285:  MOVWF  4B
0286:  MOVF   47,W
0287:  XORWF  4B,F
0288:  BTFSS  4B.7
0289:  GOTO   28C
028A:  BSF    78.7
028B:  GOTO   292
028C:  BCF    78.7
028D:  GOTO   292
028E:  CLRF   77
028F:  CLRF   78
0290:  CLRF   79
0291:  CLRF   7A
0292:  MOVF   7A,W
0293:  MOVWF  38
0294:  MOVF   79,W
0295:  MOVWF  37
0296:  MOVF   78,W
0297:  MOVWF  36
0298:  MOVF   77,W
0299:  MOVWF  35
029A:  DECFSZ 3C,F
029B:  GOTO   210
029C:  MOVF   38,W
029D:  MOVWF  45
029E:  MOVF   37,W
029F:  MOVWF  44
02A0:  MOVF   36,W
02A1:  MOVWF  43
02A2:  MOVF   35,W
02A3:  MOVWF  42
02A4:  MOVF   42,W
02A5:  SUBLW  B6
02A6:  MOVWF  42
02A7:  CLRF   7A
02A8:  MOVF   43,W
02A9:  MOVWF  46
02AA:  BSF    43.7
02AB:  BCF    03.0
02AC:  RRF    43,F
02AD:  RRF    44,F
02AE:  RRF    45,F
02AF:  RRF    7A,F
02B0:  RRF    79,F
02B1:  RRF    78,F
02B2:  RRF    77,F
02B3:  DECFSZ 42,F
02B4:  GOTO   2AB
02B5:  BTFSS  46.7
02B6:  GOTO   2C2
02B7:  COMF   77,F
02B8:  COMF   78,F
02B9:  COMF   79,F
02BA:  COMF   7A,F
02BB:  INCF   77,F
02BC:  BTFSC  03.2
02BD:  INCF   78,F
02BE:  BTFSC  03.2
02BF:  INCF   79,F
02C0:  BTFSC  03.2
02C1:  INCF   7A,F
02C2:  MOVF   7A,W
02C3:  MOVWF  38
02C4:  MOVF   79,W
02C5:  MOVWF  37
02C6:  MOVF   78,W
02C7:  MOVWF  36
02C8:  MOVF   77,W
02C9:  MOVWF  35
02CA:  BTFSS  38.7
02CB:  GOTO   2D9
02CC:  DECF   3A,F
02CD:  BSF    3A.5
02CE:  COMF   35,F
02CF:  COMF   36,F
02D0:  COMF   37,F
02D1:  COMF   38,F
02D2:  INCF   35,F
02D3:  BTFSC  03.2
02D4:  INCF   36,F
02D5:  BTFSC  03.2
02D6:  INCF   37,F
02D7:  BTFSC  03.2
02D8:  INCF   38,F
02D9:  MOVLW  3B
02DA:  MOVWF  41
02DB:  MOVLW  9A
02DC:  MOVWF  40
02DD:  MOVLW  CA
02DE:  MOVWF  3F
02DF:  CLRF   3E
02E0:  MOVLW  0A
02E1:  MOVWF  3C
02E2:  MOVF   39,W
02E3:  BTFSC  03.2
02E4:  INCF   3A,F
02E5:  BSF    03.1
02E6:  MOVLW  35
02E7:  MOVWF  04
02E8:  BCF    03.7
02E9:  MOVF   38,W
02EA:  MOVWF  45
02EB:  MOVF   37,W
02EC:  MOVWF  44
02ED:  MOVF   36,W
02EE:  MOVWF  43
02EF:  MOVF   35,W
02F0:  MOVWF  42
02F1:  MOVF   41,W
02F2:  MOVWF  49
02F3:  MOVF   40,W
02F4:  MOVWF  48
02F5:  MOVF   3F,W
02F6:  MOVWF  47
02F7:  MOVF   3E,W
02F8:  MOVWF  46
02F9:  CALL   1BB
02FA:  MOVF   78,W
02FB:  MOVF   77,F
02FC:  BTFSS  03.2
02FD:  GOTO   311
02FE:  INCF   39,W
02FF:  SUBWF  3C,W
0300:  BTFSC  03.2
0301:  GOTO   311
0302:  MOVF   3A,W
0303:  BTFSC  03.2
0304:  GOTO   313
0305:  ANDLW  0F
0306:  SUBWF  3C,W
0307:  BTFSC  03.2
0308:  GOTO   30B
0309:  BTFSC  03.0
030A:  GOTO   347
030B:  BTFSC  3A.7
030C:  GOTO   347
030D:  BTFSC  3A.6
030E:  GOTO   313
030F:  MOVLW  20
0310:  GOTO   342
0311:  MOVLW  20
0312:  ANDWF  3A,F
0313:  BTFSS  3A.5
0314:  GOTO   322
0315:  BCF    3A.5
0316:  MOVF   39,W
0317:  BTFSS  03.2
0318:  DECF   3A,F
0319:  MOVF   77,W
031A:  MOVWF  3A
031B:  MOVLW  2D
031C:  BTFSS  0C.4
031D:  GOTO   31C
031E:  MOVWF  19
031F:  MOVF   3A,W
0320:  MOVWF  77
0321:  CLRF   3A
0322:  MOVF   39,W
0323:  SUBWF  3C,W
0324:  BTFSS  03.2
0325:  GOTO   331
0326:  MOVF   77,W
0327:  MOVWF  3A
0328:  MOVLW  2E
0329:  BTFSS  0C.4
032A:  GOTO   329
032B:  MOVWF  19
032C:  MOVF   3A,W
032D:  MOVWF  77
032E:  MOVLW  20
032F:  ANDWF  3A,F
0330:  MOVLW  00
0331:  MOVLW  30
0332:  BTFSS  3A.5
0333:  GOTO   342
0334:  BCF    3A.5
0335:  MOVF   39,W
0336:  BTFSS  03.2
0337:  DECF   3A,F
0338:  MOVF   77,W
0339:  MOVWF  3A
033A:  MOVLW  2D
033B:  BTFSS  0C.4
033C:  GOTO   33B
033D:  MOVWF  19
033E:  MOVF   3A,W
033F:  MOVWF  77
0340:  CLRF   3A
0341:  MOVLW  30
0342:  ADDWF  77,F
0343:  MOVF   77,W
0344:  BTFSS  0C.4
0345:  GOTO   344
0346:  MOVWF  19
0347:  BCF    03.1
0348:  MOVF   41,W
0349:  MOVWF  45
034A:  MOVF   40,W
034B:  MOVWF  44
034C:  MOVF   3F,W
034D:  MOVWF  43
034E:  MOVF   3E,W
034F:  MOVWF  42
0350:  CLRF   49
0351:  CLRF   48
0352:  CLRF   47
0353:  MOVLW  0A
0354:  MOVWF  46
0355:  CALL   1BB
0356:  MOVF   7A,W
0357:  MOVWF  41
0358:  MOVF   79,W
0359:  MOVWF  40
035A:  MOVF   78,W
035B:  MOVWF  3F
035C:  MOVF   77,W
035D:  MOVWF  3E
035E:  DECFSZ 3C,F
035F:  GOTO   2E5
0360:  RETURN
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO,MCLR,NOWDT,NOLVP 
.................... #use delay(clock=4M) 
0361:  MOVLW  36
0362:  MOVWF  04
0363:  BCF    03.7
0364:  MOVF   00,W
0365:  BTFSC  03.2
0366:  GOTO   375
0367:  MOVLW  01
0368:  MOVWF  78
0369:  CLRF   77
036A:  DECFSZ 77,F
036B:  GOTO   36A
036C:  DECFSZ 78,F
036D:  GOTO   369
036E:  MOVLW  4A
036F:  MOVWF  77
0370:  DECFSZ 77,F
0371:  GOTO   370
0372:  GOTO   373
0373:  DECFSZ 00,F
0374:  GOTO   367
0375:  BCF    0A.3
0376:  BCF    0A.4
0377:  GOTO   405 (RETURN)
....................  
.................... #use rs232(baud=9600, parity=N, xmit=PIN_C6, rcv=PIN_C7, bits=8) 
.................... #use standard_io(C) 
.................... #use standard_io(B)  
.................... #use standard_io(A) 
....................  
.................... #include<stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
039B:  BCF    03.6
039C:  CLRF   21
039D:  CLRF   22
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define TRIGDEL PIN_C0 
.................... #define ECHODEL PIN_C1 
.................... #define TRIGDER PIN_C2 
.................... #define ECHODER PIN_C3 
.................... #define TRIGIZQ PIN_C4 
.................... #define ECHOIZQ PIN_C5 
....................  
.................... int16 duration; 
.................... float distanceDelante; 
.................... float distanceDerecha; 
.................... float distanceIzquierda; 
....................  
.................... void sr04distDelante() { 
....................     enable_interrupts(INT_TIMER1); 
*
0060:  BSF    03.5
0061:  BSF    0C.0
....................     output_low(TRIGDEL); 
0062:  BCF    03.5
0063:  BCF    20.0
0064:  MOVF   20,W
0065:  BSF    03.5
0066:  MOVWF  07
0067:  BCF    03.5
0068:  BCF    07.0
....................     delay_us(2); 
0069:  GOTO   06A
....................     output_high(TRIGDEL); 
006A:  BCF    20.0
006B:  MOVF   20,W
006C:  BSF    03.5
006D:  MOVWF  07
006E:  BCF    03.5
006F:  BSF    07.0
....................     delay_us(10); 
0070:  MOVLW  02
0071:  MOVWF  77
0072:  DECFSZ 77,F
0073:  GOTO   072
0074:  GOTO   075
0075:  NOP
....................     output_low(TRIGDEL); 
0076:  BCF    20.0
0077:  MOVF   20,W
0078:  BSF    03.5
0079:  MOVWF  07
007A:  BCF    03.5
007B:  BCF    07.0
....................  
....................     while (!input(ECHODEL)); 
007C:  BSF    20.1
007D:  MOVF   20,W
007E:  BSF    03.5
007F:  MOVWF  07
0080:  BCF    03.5
0081:  BTFSS  07.1
0082:  GOTO   07C
....................     set_timer1(0); 
0083:  CLRF   0E
0084:  CLRF   0F
0085:  CLRF   0E
....................     while (input(ECHODEL)); 
0086:  BSF    20.1
0087:  MOVF   20,W
0088:  BSF    03.5
0089:  MOVWF  07
008A:  BCF    03.5
008B:  BTFSC  07.1
008C:  GOTO   086
....................     duration = get_timer1(); 
008D:  MOVF   0F,W
008E:  MOVWF  7A
008F:  MOVF   0E,W
0090:  MOVWF  77
0091:  MOVF   0F,W
0092:  SUBWF  7A,W
0093:  BTFSS  03.2
0094:  GOTO   08D
0095:  MOVF   77,W
0096:  MOVWF  27
0097:  MOVF   7A,W
0098:  MOVWF  28
....................  
....................     distanceDelante = (duration / 58); 
0099:  MOVF   28,W
009A:  MOVWF  36
009B:  MOVF   27,W
009C:  MOVWF  35
009D:  CLRF   38
009E:  MOVLW  3A
009F:  MOVWF  37
00A0:  CALL   01E
00A1:  MOVF   79,W
00A2:  MOVWF  7A
00A3:  MOVF   78,W
00A4:  MOVWF  35
00A5:  MOVF   79,W
00A6:  MOVWF  36
00A7:  CALL   043
00A8:  MOVF   7A,W
00A9:  MOVWF  2C
00AA:  MOVF   79,W
00AB:  MOVWF  2B
00AC:  MOVF   78,W
00AD:  MOVWF  2A
00AE:  MOVF   77,W
00AF:  MOVWF  29
....................     disable_interrupts(INT_TIMER1); 
00B0:  BSF    03.5
00B1:  BCF    0C.0
00B2:  BCF    03.5
00B3:  BCF    0A.3
00B4:  BCF    0A.4
00B5:  GOTO   3A7 (RETURN)
.................... } 
....................  
.................... void sr04distDerecha() { 
....................     enable_interrupts(INT_TIMER1); 
00B6:  BSF    03.5
00B7:  BSF    0C.0
....................     output_low(TRIGDER); 
00B8:  BCF    03.5
00B9:  BCF    20.2
00BA:  MOVF   20,W
00BB:  BSF    03.5
00BC:  MOVWF  07
00BD:  BCF    03.5
00BE:  BCF    07.2
....................     delay_us(2); 
00BF:  GOTO   0C0
....................     output_high(TRIGDER); 
00C0:  BCF    20.2
00C1:  MOVF   20,W
00C2:  BSF    03.5
00C3:  MOVWF  07
00C4:  BCF    03.5
00C5:  BSF    07.2
....................     delay_us(10); 
00C6:  MOVLW  02
00C7:  MOVWF  77
00C8:  DECFSZ 77,F
00C9:  GOTO   0C8
00CA:  GOTO   0CB
00CB:  NOP
....................     output_low(TRIGDER); 
00CC:  BCF    20.2
00CD:  MOVF   20,W
00CE:  BSF    03.5
00CF:  MOVWF  07
00D0:  BCF    03.5
00D1:  BCF    07.2
....................  
....................     while (!input(ECHODER)); 
00D2:  BSF    20.3
00D3:  MOVF   20,W
00D4:  BSF    03.5
00D5:  MOVWF  07
00D6:  BCF    03.5
00D7:  BTFSS  07.3
00D8:  GOTO   0D2
....................     set_timer1(0); 
00D9:  CLRF   0E
00DA:  CLRF   0F
00DB:  CLRF   0E
....................     while (input(ECHODER)); 
00DC:  BSF    20.3
00DD:  MOVF   20,W
00DE:  BSF    03.5
00DF:  MOVWF  07
00E0:  BCF    03.5
00E1:  BTFSC  07.3
00E2:  GOTO   0DC
....................     duration = get_timer1(); 
00E3:  MOVF   0F,W
00E4:  MOVWF  7A
00E5:  MOVF   0E,W
00E6:  MOVWF  77
00E7:  MOVF   0F,W
00E8:  SUBWF  7A,W
00E9:  BTFSS  03.2
00EA:  GOTO   0E3
00EB:  MOVF   77,W
00EC:  MOVWF  27
00ED:  MOVF   7A,W
00EE:  MOVWF  28
....................  
....................     distanceDerecha = (duration / 58); 
00EF:  MOVF   28,W
00F0:  MOVWF  36
00F1:  MOVF   27,W
00F2:  MOVWF  35
00F3:  CLRF   38
00F4:  MOVLW  3A
00F5:  MOVWF  37
00F6:  CALL   01E
00F7:  MOVF   79,W
00F8:  MOVWF  7A
00F9:  MOVF   78,W
00FA:  MOVWF  35
00FB:  MOVF   79,W
00FC:  MOVWF  36
00FD:  CALL   043
00FE:  MOVF   7A,W
00FF:  MOVWF  30
0100:  MOVF   79,W
0101:  MOVWF  2F
0102:  MOVF   78,W
0103:  MOVWF  2E
0104:  MOVF   77,W
0105:  MOVWF  2D
....................     disable_interrupts(INT_TIMER1); 
0106:  BSF    03.5
0107:  BCF    0C.0
0108:  BCF    03.5
0109:  BCF    0A.3
010A:  BCF    0A.4
010B:  GOTO   3A8 (RETURN)
.................... } 
....................  
.................... void sr04distIzquierda() { 
....................     enable_interrupts(INT_TIMER1); 
010C:  BSF    03.5
010D:  BSF    0C.0
....................     output_low(TRIGIZQ); 
010E:  BCF    03.5
010F:  BCF    20.4
0110:  MOVF   20,W
0111:  BSF    03.5
0112:  MOVWF  07
0113:  BCF    03.5
0114:  BCF    07.4
....................     delay_us(2); 
0115:  GOTO   116
....................     output_high(TRIGIZQ); 
0116:  BCF    20.4
0117:  MOVF   20,W
0118:  BSF    03.5
0119:  MOVWF  07
011A:  BCF    03.5
011B:  BSF    07.4
....................     delay_us(10); 
011C:  MOVLW  02
011D:  MOVWF  77
011E:  DECFSZ 77,F
011F:  GOTO   11E
0120:  GOTO   121
0121:  NOP
....................     output_low(TRIGIZQ); 
0122:  BCF    20.4
0123:  MOVF   20,W
0124:  BSF    03.5
0125:  MOVWF  07
0126:  BCF    03.5
0127:  BCF    07.4
....................  
....................     while (!input(ECHOIZQ)); 
0128:  BSF    20.5
0129:  MOVF   20,W
012A:  BSF    03.5
012B:  MOVWF  07
012C:  BCF    03.5
012D:  BTFSS  07.5
012E:  GOTO   128
....................     set_timer1(0); 
012F:  CLRF   0E
0130:  CLRF   0F
0131:  CLRF   0E
....................     while (input(ECHOIZQ)); 
0132:  BSF    20.5
0133:  MOVF   20,W
0134:  BSF    03.5
0135:  MOVWF  07
0136:  BCF    03.5
0137:  BTFSC  07.5
0138:  GOTO   132
....................     duration = get_timer1(); 
0139:  MOVF   0F,W
013A:  MOVWF  7A
013B:  MOVF   0E,W
013C:  MOVWF  77
013D:  MOVF   0F,W
013E:  SUBWF  7A,W
013F:  BTFSS  03.2
0140:  GOTO   139
0141:  MOVF   77,W
0142:  MOVWF  27
0143:  MOVF   7A,W
0144:  MOVWF  28
....................     distanceIzquierda = (duration / 58); 
0145:  MOVF   28,W
0146:  MOVWF  36
0147:  MOVF   27,W
0148:  MOVWF  35
0149:  CLRF   38
014A:  MOVLW  3A
014B:  MOVWF  37
014C:  CALL   01E
014D:  MOVF   79,W
014E:  MOVWF  7A
014F:  MOVF   78,W
0150:  MOVWF  35
0151:  MOVF   79,W
0152:  MOVWF  36
0153:  CALL   043
0154:  MOVF   7A,W
0155:  MOVWF  34
0156:  MOVF   79,W
0157:  MOVWF  33
0158:  MOVF   78,W
0159:  MOVWF  32
015A:  MOVF   77,W
015B:  MOVWF  31
....................     disable_interrupts(INT_TIMER1); 
015C:  BSF    03.5
015D:  BCF    0C.0
015E:  BCF    03.5
015F:  BCF    0A.3
0160:  BCF    0A.4
0161:  GOTO   3A9 (RETURN)
.................... } 
....................  
.................... void main() { 
*
0378:  MOVF   03,W
0379:  ANDLW  1F
037A:  MOVWF  03
037B:  MOVLW  61
037C:  BSF    03.5
037D:  MOVWF  0F
037E:  MOVF   0F,W
037F:  BSF    03.6
0380:  BCF    07.3
0381:  MOVLW  19
0382:  BCF    03.6
0383:  MOVWF  19
0384:  MOVLW  A6
0385:  MOVWF  18
0386:  MOVLW  90
0387:  BCF    03.5
0388:  MOVWF  18
0389:  MOVLW  FF
038A:  MOVWF  20
038B:  BSF    03.5
038C:  BSF    03.6
038D:  MOVF   09,W
038E:  ANDLW  C0
038F:  MOVWF  09
0390:  BCF    03.6
0391:  BCF    1F.4
0392:  BCF    1F.5
0393:  MOVLW  00
0394:  BSF    03.6
0395:  MOVWF  08
0396:  BCF    03.5
0397:  CLRF   07
0398:  CLRF   08
0399:  CLRF   09
039A:  BCF    03.7
....................     enable_interrupts(INT_TIMER1); 
*
039E:  BSF    03.5
039F:  BSF    0C.0
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_1); 
03A0:  MOVLW  05
03A1:  BCF    03.5
03A2:  MOVWF  10
....................     set_timer1(0); 
03A3:  CLRF   0E
03A4:  CLRF   0F
03A5:  CLRF   0E
....................     while (1) { 
....................         sr04distDelante(); 
03A6:  GOTO   060
....................         sr04distDerecha(); 
03A7:  GOTO   0B6
....................         sr04distIzquierda(); 
03A8:  GOTO   10C
....................         printf("Delante: %.2f\n", distanceDelante); 
03A9:  MOVLW  04
03AA:  BSF    03.6
03AB:  MOVWF  0D
03AC:  MOVLW  00
03AD:  MOVWF  0F
03AE:  BCF    03.0
03AF:  MOVLW  09
03B0:  BCF    03.6
03B1:  MOVWF  35
03B2:  CALL   162
03B3:  MOVLW  89
03B4:  MOVWF  04
03B5:  MOVF   2C,W
03B6:  MOVWF  38
03B7:  MOVF   2B,W
03B8:  MOVWF  37
03B9:  MOVF   2A,W
03BA:  MOVWF  36
03BB:  MOVF   29,W
03BC:  MOVWF  35
03BD:  MOVLW  02
03BE:  MOVWF  39
03BF:  CALL   20A
03C0:  MOVLW  0A
03C1:  BTFSS  0C.4
03C2:  GOTO   3C1
03C3:  MOVWF  19
....................         printf("Derecha: %.2f\n", distanceDerecha); 
03C4:  MOVLW  0C
03C5:  BSF    03.6
03C6:  MOVWF  0D
03C7:  MOVLW  00
03C8:  MOVWF  0F
03C9:  BCF    03.0
03CA:  MOVLW  09
03CB:  BCF    03.6
03CC:  MOVWF  35
03CD:  CALL   162
03CE:  MOVLW  89
03CF:  MOVWF  04
03D0:  MOVF   30,W
03D1:  MOVWF  38
03D2:  MOVF   2F,W
03D3:  MOVWF  37
03D4:  MOVF   2E,W
03D5:  MOVWF  36
03D6:  MOVF   2D,W
03D7:  MOVWF  35
03D8:  MOVLW  02
03D9:  MOVWF  39
03DA:  CALL   20A
03DB:  MOVLW  0A
03DC:  BTFSS  0C.4
03DD:  GOTO   3DC
03DE:  MOVWF  19
....................         printf("Izquierda: %.2f\n\n\n\n", distanceIzquierda); 
03DF:  MOVLW  14
03E0:  BSF    03.6
03E1:  MOVWF  0D
03E2:  MOVLW  00
03E3:  MOVWF  0F
03E4:  BCF    03.0
03E5:  MOVLW  0B
03E6:  BCF    03.6
03E7:  MOVWF  35
03E8:  CALL   162
03E9:  MOVLW  89
03EA:  MOVWF  04
03EB:  MOVF   34,W
03EC:  MOVWF  38
03ED:  MOVF   33,W
03EE:  MOVWF  37
03EF:  MOVF   32,W
03F0:  MOVWF  36
03F1:  MOVF   31,W
03F2:  MOVWF  35
03F3:  MOVLW  02
03F4:  MOVWF  39
03F5:  CALL   20A
03F6:  MOVLW  1B
03F7:  BSF    03.6
03F8:  MOVWF  0D
03F9:  MOVLW  00
03FA:  MOVWF  0F
03FB:  BSF    03.0
03FC:  MOVLW  04
03FD:  BCF    03.6
03FE:  MOVWF  35
03FF:  CALL   162
....................         delay_ms(1000); 
0400:  MOVLW  04
0401:  MOVWF  35
0402:  MOVLW  FA
0403:  MOVWF  36
0404:  GOTO   361
0405:  DECFSZ 35,F
0406:  GOTO   402
0407:  GOTO   3A6
....................     } 
.................... } 
0408:  SLEEP

Configuration Fuses:
   Word  1: 2FE4   INTRC_IO NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
