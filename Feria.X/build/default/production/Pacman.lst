CCS PCM C Compiler, Version 5.015, 5967               28-feb-25 09:32

               Filename:   C:\Users\Electronica\Downloads\Feria.X\build\default\production\Pacman.lst

               ROM used:   1845 words (23%)
                           Largest free fragment is 2048
               RAM used:   26 (7%) at main() level
                           67 (18%) worst case
               Stack used: 9 locations (4 in main + 5 for interrupts)
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   485
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   056
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.0
002E:  GOTO   031
002F:  BTFSC  0C.0
0030:  GOTO   059
0031:  BTFSS  0B.5
0032:  GOTO   035
0033:  BTFSC  0B.2
0034:  GOTO   05C
0035:  MOVF   22,W
0036:  MOVWF  04
0037:  MOVF   23,W
0038:  MOVWF  77
0039:  MOVF   24,W
003A:  MOVWF  78
003B:  MOVF   25,W
003C:  MOVWF  79
003D:  MOVF   26,W
003E:  MOVWF  7A
003F:  MOVF   27,W
0040:  BSF    03.6
0041:  MOVWF  0D
0042:  BCF    03.6
0043:  MOVF   28,W
0044:  BSF    03.6
0045:  MOVWF  0F
0046:  BCF    03.6
0047:  MOVF   29,W
0048:  BSF    03.6
0049:  MOVWF  0C
004A:  BCF    03.6
004B:  MOVF   2A,W
004C:  BSF    03.6
004D:  MOVWF  0E
004E:  BCF    03.6
004F:  MOVF   20,W
0050:  MOVWF  0A
0051:  SWAPF  21,W
0052:  MOVWF  03
0053:  SWAPF  7F,F
0054:  SWAPF  7F,W
0055:  RETFIE
0056:  BCF    0A.3
0057:  BCF    0A.4
0058:  GOTO   25A
0059:  BCF    0A.3
005A:  BCF    0A.4
005B:  GOTO   37B
005C:  BCF    0A.3
005D:  BCF    0A.4
005E:  GOTO   370
.................... #include<16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
*
01B5:  MOVF   0B,W
01B6:  MOVWF  41
01B7:  BCF    0B.7
01B8:  BSF    03.5
01B9:  BSF    03.6
01BA:  BSF    0C.7
01BB:  BSF    0C.0
01BC:  NOP
01BD:  NOP
01BE:  BCF    03.5
01BF:  BCF    03.6
01C0:  BTFSC  41.7
01C1:  BSF    0B.7
01C2:  BSF    03.6
01C3:  MOVF   0C,W
01C4:  ANDLW  7F
01C5:  BTFSC  03.2
01C6:  GOTO   209
01C7:  BCF    03.6
01C8:  MOVWF  41
01C9:  BSF    03.6
01CA:  MOVF   0D,W
01CB:  BCF    03.6
01CC:  MOVWF  42
01CD:  BSF    03.6
01CE:  MOVF   0F,W
01CF:  BCF    03.6
01D0:  MOVWF  43
01D1:  MOVF   41,W
01D2:  MOVWF  51
01D3:  CALL   156
01D4:  MOVF   42,W
01D5:  BSF    03.6
01D6:  MOVWF  0D
01D7:  BCF    03.6
01D8:  MOVF   43,W
01D9:  BSF    03.6
01DA:  MOVWF  0F
01DB:  BCF    03.6
01DC:  MOVF   0B,W
01DD:  MOVWF  44
01DE:  BCF    0B.7
01DF:  BSF    03.5
01E0:  BSF    03.6
01E1:  BSF    0C.7
01E2:  BSF    0C.0
01E3:  NOP
01E4:  NOP
01E5:  BCF    03.5
01E6:  BCF    03.6
01E7:  BTFSC  44.7
01E8:  BSF    0B.7
01E9:  BSF    03.6
01EA:  RLF    0C,W
01EB:  RLF    0E,W
01EC:  ANDLW  7F
01ED:  BTFSC  03.2
01EE:  GOTO   209
01EF:  BCF    03.6
01F0:  MOVWF  41
01F1:  BSF    03.6
01F2:  MOVF   0D,W
01F3:  BCF    03.6
01F4:  MOVWF  42
01F5:  BSF    03.6
01F6:  MOVF   0F,W
01F7:  BCF    03.6
01F8:  MOVWF  43
01F9:  MOVF   41,W
01FA:  MOVWF  51
01FB:  CALL   156
01FC:  MOVF   42,W
01FD:  BSF    03.6
01FE:  MOVWF  0D
01FF:  BCF    03.6
0200:  MOVF   43,W
0201:  BSF    03.6
0202:  MOVWF  0F
0203:  INCF   0D,F
0204:  BTFSC  03.2
0205:  INCF   0F,F
0206:  BCF    03.6
0207:  GOTO   1B5
0208:  BSF    03.6
0209:  BCF    03.6
020A:  RETURN
020B:  BTFSC  03.1
020C:  GOTO   210
020D:  MOVLW  59
020E:  MOVWF  04
020F:  BCF    03.7
0210:  CLRF   77
0211:  CLRF   78
0212:  CLRF   79
0213:  CLRF   7A
0214:  CLRF   59
0215:  CLRF   5A
0216:  CLRF   5B
0217:  CLRF   5C
0218:  MOVF   58,W
0219:  IORWF  57,W
021A:  IORWF  56,W
021B:  IORWF  55,W
021C:  BTFSC  03.2
021D:  GOTO   24E
021E:  MOVLW  20
021F:  MOVWF  5D
0220:  BCF    03.0
0221:  RLF    51,F
0222:  RLF    52,F
0223:  RLF    53,F
0224:  RLF    54,F
0225:  RLF    59,F
0226:  RLF    5A,F
0227:  RLF    5B,F
0228:  RLF    5C,F
0229:  MOVF   58,W
022A:  SUBWF  5C,W
022B:  BTFSS  03.2
022C:  GOTO   237
022D:  MOVF   57,W
022E:  SUBWF  5B,W
022F:  BTFSS  03.2
0230:  GOTO   237
0231:  MOVF   56,W
0232:  SUBWF  5A,W
0233:  BTFSS  03.2
0234:  GOTO   237
0235:  MOVF   55,W
0236:  SUBWF  59,W
0237:  BTFSS  03.0
0238:  GOTO   248
0239:  MOVF   55,W
023A:  SUBWF  59,F
023B:  MOVF   56,W
023C:  BTFSS  03.0
023D:  INCFSZ 56,W
023E:  SUBWF  5A,F
023F:  MOVF   57,W
0240:  BTFSS  03.0
0241:  INCFSZ 57,W
0242:  SUBWF  5B,F
0243:  MOVF   58,W
0244:  BTFSS  03.0
0245:  INCFSZ 58,W
0246:  SUBWF  5C,F
0247:  BSF    03.0
0248:  RLF    77,F
0249:  RLF    78,F
024A:  RLF    79,F
024B:  RLF    7A,F
024C:  DECFSZ 5D,F
024D:  GOTO   220
024E:  MOVF   59,W
024F:  MOVWF  00
0250:  INCF   04,F
0251:  MOVF   5A,W
0252:  MOVWF  00
0253:  INCF   04,F
0254:  MOVF   5B,W
0255:  MOVWF  00
0256:  INCF   04,F
0257:  MOVF   5C,W
0258:  MOVWF  00
0259:  RETURN
*
026F:  MOVLW  20
0270:  MOVWF  4D
0271:  CLRF   49
0272:  CLRF   4A
0273:  CLRF   4B
0274:  CLRF   4C
0275:  MOVF   44,W
0276:  MOVWF  7A
0277:  MOVF   43,W
0278:  MOVWF  79
0279:  MOVF   42,W
027A:  MOVWF  78
027B:  MOVF   41,W
027C:  MOVWF  77
027D:  BCF    03.0
027E:  BTFSS  77.0
027F:  GOTO   28E
0280:  MOVF   45,W
0281:  ADDWF  49,F
0282:  MOVF   46,W
0283:  BTFSC  03.0
0284:  INCFSZ 46,W
0285:  ADDWF  4A,F
0286:  MOVF   47,W
0287:  BTFSC  03.0
0288:  INCFSZ 47,W
0289:  ADDWF  4B,F
028A:  MOVF   48,W
028B:  BTFSC  03.0
028C:  INCFSZ 48,W
028D:  ADDWF  4C,F
028E:  RRF    4C,F
028F:  RRF    4B,F
0290:  RRF    4A,F
0291:  RRF    49,F
0292:  RRF    7A,F
0293:  RRF    79,F
0294:  RRF    78,F
0295:  RRF    77,F
0296:  DECFSZ 4D,F
0297:  GOTO   27D
*
02A9:  MOVF   0B,W
02AA:  MOVWF  46
02AB:  BCF    0B.7
02AC:  BSF    03.5
02AD:  BSF    03.6
02AE:  BSF    0C.7
02AF:  BSF    0C.0
02B0:  NOP
02B1:  NOP
02B2:  BCF    03.5
02B3:  BCF    03.6
02B4:  BTFSC  46.7
02B5:  BSF    0B.7
02B6:  BTFSC  03.0
02B7:  GOTO   2E0
02B8:  BSF    03.6
02B9:  MOVF   0C,W
02BA:  ANDLW  7F
02BB:  BCF    03.6
02BC:  MOVWF  46
02BD:  BSF    03.6
02BE:  MOVF   0D,W
02BF:  BCF    03.6
02C0:  MOVWF  47
02C1:  BSF    03.6
02C2:  MOVF   0F,W
02C3:  BCF    03.6
02C4:  MOVWF  48
02C5:  MOVF   46,W
02C6:  MOVWF  51
02C7:  CALL   156
02C8:  MOVF   47,W
02C9:  BSF    03.6
02CA:  MOVWF  0D
02CB:  BCF    03.6
02CC:  MOVF   48,W
02CD:  BSF    03.6
02CE:  MOVWF  0F
02CF:  BCF    03.6
02D0:  MOVF   0B,W
02D1:  MOVWF  49
02D2:  BCF    0B.7
02D3:  BSF    03.5
02D4:  BSF    03.6
02D5:  BSF    0C.7
02D6:  BSF    0C.0
02D7:  NOP
02D8:  NOP
02D9:  BCF    03.5
02DA:  BCF    03.6
02DB:  BTFSC  49.7
02DC:  BSF    0B.7
02DD:  DECFSZ 45,F
02DE:  GOTO   2E0
02DF:  GOTO   2FF
02E0:  BSF    03.6
02E1:  RLF    0C,W
02E2:  RLF    0E,W
02E3:  ANDLW  7F
02E4:  BCF    03.6
02E5:  MOVWF  46
02E6:  BSF    03.6
02E7:  MOVF   0D,W
02E8:  BCF    03.6
02E9:  MOVWF  47
02EA:  BSF    03.6
02EB:  MOVF   0F,W
02EC:  BCF    03.6
02ED:  MOVWF  48
02EE:  MOVF   46,W
02EF:  MOVWF  51
02F0:  CALL   156
02F1:  MOVF   47,W
02F2:  BSF    03.6
02F3:  MOVWF  0D
02F4:  BCF    03.6
02F5:  MOVF   48,W
02F6:  BSF    03.6
02F7:  MOVWF  0F
02F8:  INCF   0D,F
02F9:  BTFSC  03.2
02FA:  INCF   0F,F
02FB:  BCF    03.0
02FC:  BCF    03.6
02FD:  DECFSZ 45,F
02FE:  GOTO   2A9
*
0309:  MOVF   04,W
030A:  MOVWF  49
030B:  MOVLW  3B
030C:  MOVWF  50
030D:  MOVLW  9A
030E:  MOVWF  4F
030F:  MOVLW  CA
0310:  MOVWF  4E
0311:  CLRF   4D
0312:  MOVLW  0A
0313:  MOVWF  4B
0314:  BSF    03.1
0315:  MOVLW  45
0316:  MOVWF  04
0317:  BCF    03.7
0318:  MOVF   48,W
0319:  MOVWF  54
031A:  MOVF   47,W
031B:  MOVWF  53
031C:  MOVF   46,W
031D:  MOVWF  52
031E:  MOVF   45,W
031F:  MOVWF  51
0320:  MOVF   50,W
0321:  MOVWF  58
0322:  MOVF   4F,W
0323:  MOVWF  57
0324:  MOVF   4E,W
0325:  MOVWF  56
0326:  MOVF   4D,W
0327:  MOVWF  55
0328:  CALL   20B
0329:  MOVF   78,W
032A:  MOVF   77,F
032B:  BTFSS  03.2
032C:  GOTO   340
032D:  MOVF   4B,W
032E:  XORLW  01
032F:  BTFSC  03.2
0330:  GOTO   340
0331:  MOVF   49,W
0332:  BTFSC  03.2
0333:  GOTO   341
0334:  ANDLW  0F
0335:  SUBWF  4B,W
0336:  BTFSC  03.2
0337:  GOTO   33A
0338:  BTFSC  03.0
0339:  GOTO   346
033A:  BTFSC  49.7
033B:  GOTO   346
033C:  BTFSC  49.6
033D:  GOTO   341
033E:  MOVLW  20
033F:  GOTO   342
0340:  CLRF   49
0341:  MOVLW  30
0342:  ADDWF  77,F
0343:  MOVF   77,W
0344:  MOVWF  51
0345:  CALL   156
0346:  BCF    03.1
0347:  MOVF   50,W
0348:  MOVWF  54
0349:  MOVF   4F,W
034A:  MOVWF  53
034B:  MOVF   4E,W
034C:  MOVWF  52
034D:  MOVF   4D,W
034E:  MOVWF  51
034F:  CLRF   58
0350:  CLRF   57
0351:  CLRF   56
0352:  MOVLW  0A
0353:  MOVWF  55
0354:  CALL   20B
0355:  MOVF   7A,W
0356:  MOVWF  50
0357:  MOVF   79,W
0358:  MOVWF  4F
0359:  MOVF   78,W
035A:  MOVWF  4E
035B:  MOVF   77,W
035C:  MOVWF  4D
035D:  DECFSZ 4B,F
035E:  GOTO   314
*
0364:  DATA 8C,23
0365:  DATA E1,36
0366:  DATA 65,10
0367:  DATA 4F,3B
0368:  DATA 65,39
0369:  DATA 0A,00
036A:  DATA D3,31
036B:  DATA 6F,39
036C:  DATA 65,1D
036D:  DATA A0,12
036E:  DATA EC,3A
036F:  DATA 00,00
*
038C:  DATA 41,32
038D:  DATA 65,36
038E:  DATA 61,37
038F:  DATA F4,32
0390:  DATA 0A,05
0391:  DATA 00,00
0392:  DATA 8C,20
0393:  DATA E4,32
0394:  DATA EC,30
0395:  DATA 6E,3A
0396:  DATA 65,00
0397:  DATA 41,3A
0398:  DATA F2,30
0399:  DATA 73,05
039A:  DATA 0A,00
039B:  DATA 8C,20
039C:  DATA 74,39
039D:  DATA E1,39
039E:  DATA 00,00
039F:  DATA C4,32
03A0:  DATA F2,32
03A1:  DATA 63,34
03A2:  DATA 61,05
03A3:  DATA 0A,00
03A4:  DATA 0C,22
03A5:  DATA 65,39
03A6:  DATA E5,31
03A7:  DATA E8,30
03A8:  DATA 00,00
03A9:  DATA 0A,05
03AA:  DATA 49,3D
03AB:  DATA F1,3A
03AC:  DATA E9,32
03AD:  DATA 72,32
03AE:  DATA 61,05
03AF:  DATA 0A,00
03B0:  DATA 8C,24
03B1:  DATA FA,38
03B2:  DATA F5,34
03B3:  DATA 65,39
03B4:  DATA E4,30
03B5:  DATA 00,00
03B6:  DATA 0C,00
03B7:  DATA 0C,00
*
0449:  CLRF   38
044A:  BTFSS  0C.5
044B:  GOTO   44A
044C:  MOVF   1A,W
044D:  MOVWF  78
044E:  MOVF   78,W
044F:  MOVWF  7A
0450:  MOVF   7A,F
0451:  BTFSC  03.2
0452:  GOTO   480
0453:  INCF   38,F
0454:  BTFSS  37.5
0455:  GOTO   45C
0456:  BTFSC  37.0
0457:  GOTO   45C
0458:  MOVF   7A,W
0459:  SUBLW  20
045A:  BTFSC  03.0
045B:  GOTO   46C
045C:  BSF    37.0
045D:  BTFSC  37.6
045E:  GOTO   466
045F:  MOVF   35,W
0460:  MOVWF  04
0461:  BCF    03.7
0462:  BTFSC  36.0
0463:  BSF    03.7
0464:  MOVF   7A,W
0465:  MOVWF  00
0466:  BTFSS  37.7
0467:  GOTO   480
0468:  INCF   35,F
0469:  DECFSZ 36,F
046A:  GOTO   44A
046B:  GOTO   480
046C:  MOVF   7A,W
046D:  SUBLW  20
046E:  BTFSC  03.2
046F:  GOTO   47A
0470:  MOVF   7A,W
0471:  SUBLW  08
0472:  BTFSC  03.0
0473:  GOTO   478
0474:  MOVF   7A,W
0475:  SUBLW  0D
0476:  BTFSC  03.0
0477:  GOTO   47A
0478:  CLRF   78
0479:  GOTO   47C
047A:  MOVLW  01
047B:  MOVWF  78
047C:  MOVF   78,F
047D:  BTFSS  03.2
047E:  GOTO   44A
047F:  GOTO   45C
0480:  MOVF   38,W
0481:  MOVWF  78
0482:  BCF    0A.3
0483:  BCF    0A.4
0484:  GOTO   4FA (RETURN)
*
0518:  BCF    03.6
0519:  MOVF   0B,W
051A:  MOVWF  33
051B:  BCF    0B.7
051C:  BSF    03.5
051D:  BSF    03.6
051E:  BSF    0C.7
051F:  BSF    0C.0
0520:  NOP
0521:  NOP
0522:  BCF    03.5
0523:  BCF    03.6
0524:  BTFSC  33.7
0525:  BSF    0B.7
0526:  BSF    03.6
0527:  MOVF   0C,W
0528:  ANDLW  7F
0529:  BTFSC  03.2
052A:  GOTO   56D
052B:  BCF    03.6
052C:  MOVWF  33
052D:  BSF    03.6
052E:  MOVF   0D,W
052F:  BCF    03.6
0530:  MOVWF  34
0531:  BSF    03.6
0532:  MOVF   0F,W
0533:  BCF    03.6
0534:  MOVWF  35
0535:  MOVF   33,W
0536:  BTFSS  0C.4
0537:  GOTO   536
0538:  MOVWF  19
0539:  MOVF   34,W
053A:  BSF    03.6
053B:  MOVWF  0D
053C:  BCF    03.6
053D:  MOVF   35,W
053E:  BSF    03.6
053F:  MOVWF  0F
0540:  BCF    03.6
0541:  MOVF   0B,W
0542:  MOVWF  36
0543:  BCF    0B.7
0544:  BSF    03.5
0545:  BSF    03.6
0546:  BSF    0C.7
0547:  BSF    0C.0
0548:  NOP
0549:  NOP
054A:  BCF    03.5
054B:  BCF    03.6
054C:  BTFSC  36.7
054D:  BSF    0B.7
054E:  BSF    03.6
054F:  RLF    0C,W
0550:  RLF    0E,W
0551:  ANDLW  7F
0552:  BTFSC  03.2
0553:  GOTO   56D
0554:  BCF    03.6
0555:  MOVWF  33
0556:  BSF    03.6
0557:  MOVF   0D,W
0558:  BCF    03.6
0559:  MOVWF  34
055A:  BSF    03.6
055B:  MOVF   0F,W
055C:  BCF    03.6
055D:  MOVWF  35
055E:  MOVF   33,W
055F:  BTFSS  0C.4
0560:  GOTO   55F
0561:  MOVWF  19
0562:  MOVF   34,W
0563:  BSF    03.6
0564:  MOVWF  0D
0565:  BCF    03.6
0566:  MOVF   35,W
0567:  BSF    03.6
0568:  MOVWF  0F
0569:  INCF   0D,F
056A:  BTFSC  03.2
056B:  INCF   0F,F
056C:  GOTO   518
*
05A0:  BCF    03.6
05A1:  MOVF   0B,W
05A2:  MOVWF  33
05A3:  BCF    0B.7
05A4:  BSF    03.5
05A5:  BSF    03.6
05A6:  BSF    0C.7
05A7:  BSF    0C.0
05A8:  NOP
05A9:  NOP
05AA:  BCF    03.5
05AB:  BCF    03.6
05AC:  BTFSC  33.7
05AD:  BSF    0B.7
05AE:  BSF    03.6
05AF:  MOVF   0C,W
05B0:  ANDLW  7F
05B1:  BTFSC  03.2
05B2:  GOTO   5F5
05B3:  BCF    03.6
05B4:  MOVWF  33
05B5:  BSF    03.6
05B6:  MOVF   0D,W
05B7:  BCF    03.6
05B8:  MOVWF  34
05B9:  BSF    03.6
05BA:  MOVF   0F,W
05BB:  BCF    03.6
05BC:  MOVWF  35
05BD:  MOVF   33,W
05BE:  BTFSS  0C.4
05BF:  GOTO   5BE
05C0:  MOVWF  19
05C1:  MOVF   34,W
05C2:  BSF    03.6
05C3:  MOVWF  0D
05C4:  BCF    03.6
05C5:  MOVF   35,W
05C6:  BSF    03.6
05C7:  MOVWF  0F
05C8:  BCF    03.6
05C9:  MOVF   0B,W
05CA:  MOVWF  36
05CB:  BCF    0B.7
05CC:  BSF    03.5
05CD:  BSF    03.6
05CE:  BSF    0C.7
05CF:  BSF    0C.0
05D0:  NOP
05D1:  NOP
05D2:  BCF    03.5
05D3:  BCF    03.6
05D4:  BTFSC  36.7
05D5:  BSF    0B.7
05D6:  BSF    03.6
05D7:  RLF    0C,W
05D8:  RLF    0E,W
05D9:  ANDLW  7F
05DA:  BTFSC  03.2
05DB:  GOTO   5F5
05DC:  BCF    03.6
05DD:  MOVWF  33
05DE:  BSF    03.6
05DF:  MOVF   0D,W
05E0:  BCF    03.6
05E1:  MOVWF  34
05E2:  BSF    03.6
05E3:  MOVF   0F,W
05E4:  BCF    03.6
05E5:  MOVWF  35
05E6:  MOVF   33,W
05E7:  BTFSS  0C.4
05E8:  GOTO   5E7
05E9:  MOVWF  19
05EA:  MOVF   34,W
05EB:  BSF    03.6
05EC:  MOVWF  0D
05ED:  BCF    03.6
05EE:  MOVF   35,W
05EF:  BSF    03.6
05F0:  MOVWF  0F
05F1:  INCF   0D,F
05F2:  BTFSC  03.2
05F3:  INCF   0F,F
05F4:  GOTO   5A0
*
0628:  BCF    03.6
0629:  MOVF   0B,W
062A:  MOVWF  33
062B:  BCF    0B.7
062C:  BSF    03.5
062D:  BSF    03.6
062E:  BSF    0C.7
062F:  BSF    0C.0
0630:  NOP
0631:  NOP
0632:  BCF    03.5
0633:  BCF    03.6
0634:  BTFSC  33.7
0635:  BSF    0B.7
0636:  BSF    03.6
0637:  MOVF   0C,W
0638:  ANDLW  7F
0639:  BTFSC  03.2
063A:  GOTO   67D
063B:  BCF    03.6
063C:  MOVWF  33
063D:  BSF    03.6
063E:  MOVF   0D,W
063F:  BCF    03.6
0640:  MOVWF  34
0641:  BSF    03.6
0642:  MOVF   0F,W
0643:  BCF    03.6
0644:  MOVWF  35
0645:  MOVF   33,W
0646:  BTFSS  0C.4
0647:  GOTO   646
0648:  MOVWF  19
0649:  MOVF   34,W
064A:  BSF    03.6
064B:  MOVWF  0D
064C:  BCF    03.6
064D:  MOVF   35,W
064E:  BSF    03.6
064F:  MOVWF  0F
0650:  BCF    03.6
0651:  MOVF   0B,W
0652:  MOVWF  36
0653:  BCF    0B.7
0654:  BSF    03.5
0655:  BSF    03.6
0656:  BSF    0C.7
0657:  BSF    0C.0
0658:  NOP
0659:  NOP
065A:  BCF    03.5
065B:  BCF    03.6
065C:  BTFSC  36.7
065D:  BSF    0B.7
065E:  BSF    03.6
065F:  RLF    0C,W
0660:  RLF    0E,W
0661:  ANDLW  7F
0662:  BTFSC  03.2
0663:  GOTO   67D
0664:  BCF    03.6
0665:  MOVWF  33
0666:  BSF    03.6
0667:  MOVF   0D,W
0668:  BCF    03.6
0669:  MOVWF  34
066A:  BSF    03.6
066B:  MOVF   0F,W
066C:  BCF    03.6
066D:  MOVWF  35
066E:  MOVF   33,W
066F:  BTFSS  0C.4
0670:  GOTO   66F
0671:  MOVWF  19
0672:  MOVF   34,W
0673:  BSF    03.6
0674:  MOVWF  0D
0675:  BCF    03.6
0676:  MOVF   35,W
0677:  BSF    03.6
0678:  MOVWF  0F
0679:  INCF   0D,F
067A:  BTFSC  03.2
067B:  INCF   0F,F
067C:  GOTO   628
*
06AD:  BCF    03.6
06AE:  MOVF   0B,W
06AF:  MOVWF  33
06B0:  BCF    0B.7
06B1:  BSF    03.5
06B2:  BSF    03.6
06B3:  BSF    0C.7
06B4:  BSF    0C.0
06B5:  NOP
06B6:  NOP
06B7:  BCF    03.5
06B8:  BCF    03.6
06B9:  BTFSC  33.7
06BA:  BSF    0B.7
06BB:  BSF    03.6
06BC:  MOVF   0C,W
06BD:  ANDLW  7F
06BE:  BTFSC  03.2
06BF:  GOTO   702
06C0:  BCF    03.6
06C1:  MOVWF  33
06C2:  BSF    03.6
06C3:  MOVF   0D,W
06C4:  BCF    03.6
06C5:  MOVWF  34
06C6:  BSF    03.6
06C7:  MOVF   0F,W
06C8:  BCF    03.6
06C9:  MOVWF  35
06CA:  MOVF   33,W
06CB:  BTFSS  0C.4
06CC:  GOTO   6CB
06CD:  MOVWF  19
06CE:  MOVF   34,W
06CF:  BSF    03.6
06D0:  MOVWF  0D
06D1:  BCF    03.6
06D2:  MOVF   35,W
06D3:  BSF    03.6
06D4:  MOVWF  0F
06D5:  BCF    03.6
06D6:  MOVF   0B,W
06D7:  MOVWF  36
06D8:  BCF    0B.7
06D9:  BSF    03.5
06DA:  BSF    03.6
06DB:  BSF    0C.7
06DC:  BSF    0C.0
06DD:  NOP
06DE:  NOP
06DF:  BCF    03.5
06E0:  BCF    03.6
06E1:  BTFSC  36.7
06E2:  BSF    0B.7
06E3:  BSF    03.6
06E4:  RLF    0C,W
06E5:  RLF    0E,W
06E6:  ANDLW  7F
06E7:  BTFSC  03.2
06E8:  GOTO   702
06E9:  BCF    03.6
06EA:  MOVWF  33
06EB:  BSF    03.6
06EC:  MOVF   0D,W
06ED:  BCF    03.6
06EE:  MOVWF  34
06EF:  BSF    03.6
06F0:  MOVF   0F,W
06F1:  BCF    03.6
06F2:  MOVWF  35
06F3:  MOVF   33,W
06F4:  BTFSS  0C.4
06F5:  GOTO   6F4
06F6:  MOVWF  19
06F7:  MOVF   34,W
06F8:  BSF    03.6
06F9:  MOVWF  0D
06FA:  BCF    03.6
06FB:  MOVF   35,W
06FC:  BSF    03.6
06FD:  MOVWF  0F
06FE:  INCF   0D,F
06FF:  BTFSC  03.2
0700:  INCF   0F,F
0701:  GOTO   6AD
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO,MCLR,INTRC_IO,NOWDT,NOLVP 
.................... #use delay(clock=4M) 
*
017F:  MOVLW  52
0180:  MOVWF  04
0181:  BCF    03.7
0182:  MOVF   00,W
0183:  BTFSC  03.2
0184:  GOTO   193
0185:  MOVLW  01
0186:  MOVWF  78
0187:  CLRF   77
0188:  DECFSZ 77,F
0189:  GOTO   188
018A:  DECFSZ 78,F
018B:  GOTO   187
018C:  MOVLW  4A
018D:  MOVWF  77
018E:  DECFSZ 77,F
018F:  GOTO   18E
0190:  GOTO   191
0191:  DECFSZ 00,F
0192:  GOTO   185
*
03D5:  MOVLW  52
03D6:  MOVWF  04
03D7:  BCF    03.7
03D8:  MOVF   00,W
03D9:  BTFSC  03.2
03DA:  GOTO   3E9
03DB:  MOVLW  01
03DC:  MOVWF  78
03DD:  CLRF   77
03DE:  DECFSZ 77,F
03DF:  GOTO   3DE
03E0:  DECFSZ 78,F
03E1:  GOTO   3DD
03E2:  MOVLW  4A
03E3:  MOVWF  77
03E4:  DECFSZ 77,F
03E5:  GOTO   3E4
03E6:  GOTO   3E7
03E7:  DECFSZ 00,F
03E8:  GOTO   3DB
*
03FA:  MOVLW  52
03FB:  MOVWF  04
03FC:  BCF    03.7
03FD:  MOVF   00,W
03FE:  BTFSC  03.2
03FF:  GOTO   40E
0400:  MOVLW  01
0401:  MOVWF  78
0402:  CLRF   77
0403:  DECFSZ 77,F
0404:  GOTO   403
0405:  DECFSZ 78,F
0406:  GOTO   402
0407:  MOVLW  4A
0408:  MOVWF  77
0409:  DECFSZ 77,F
040A:  GOTO   409
040B:  GOTO   40C
040C:  DECFSZ 00,F
040D:  GOTO   400
*
041B:  MOVLW  52
041C:  MOVWF  04
041D:  BCF    03.7
041E:  MOVF   00,W
041F:  BTFSC  03.2
0420:  GOTO   42F
0421:  MOVLW  01
0422:  MOVWF  78
0423:  CLRF   77
0424:  DECFSZ 77,F
0425:  GOTO   424
0426:  DECFSZ 78,F
0427:  GOTO   423
0428:  MOVLW  4A
0429:  MOVWF  77
042A:  DECFSZ 77,F
042B:  GOTO   42A
042C:  GOTO   42D
042D:  DECFSZ 00,F
042E:  GOTO   421
*
0583:  MOVLW  52
0584:  MOVWF  04
0585:  BCF    03.7
0586:  MOVF   00,W
0587:  BTFSC  03.2
0588:  GOTO   597
0589:  MOVLW  01
058A:  MOVWF  78
058B:  CLRF   77
058C:  DECFSZ 77,F
058D:  GOTO   58C
058E:  DECFSZ 78,F
058F:  GOTO   58B
0590:  MOVLW  4A
0591:  MOVWF  77
0592:  DECFSZ 77,F
0593:  GOTO   592
0594:  GOTO   595
0595:  DECFSZ 00,F
0596:  GOTO   589
*
060B:  MOVLW  52
060C:  MOVWF  04
060D:  BCF    03.7
060E:  MOVF   00,W
060F:  BTFSC  03.2
0610:  GOTO   61F
0611:  MOVLW  01
0612:  MOVWF  78
0613:  CLRF   77
0614:  DECFSZ 77,F
0615:  GOTO   614
0616:  DECFSZ 78,F
0617:  GOTO   613
0618:  MOVLW  4A
0619:  MOVWF  77
061A:  DECFSZ 77,F
061B:  GOTO   61A
061C:  GOTO   61D
061D:  DECFSZ 00,F
061E:  GOTO   611
*
0693:  MOVLW  52
0694:  MOVWF  04
0695:  BCF    03.7
0696:  MOVF   00,W
0697:  BTFSC  03.2
0698:  GOTO   6A7
0699:  MOVLW  01
069A:  MOVWF  78
069B:  CLRF   77
069C:  DECFSZ 77,F
069D:  GOTO   69C
069E:  DECFSZ 78,F
069F:  GOTO   69B
06A0:  MOVLW  4A
06A1:  MOVWF  77
06A2:  DECFSZ 77,F
06A3:  GOTO   6A2
06A4:  GOTO   6A5
06A5:  DECFSZ 00,F
06A6:  GOTO   699
*
071D:  MOVLW  52
071E:  MOVWF  04
071F:  BCF    03.7
0720:  MOVF   00,W
0721:  BTFSC  03.2
0722:  GOTO   731
0723:  MOVLW  01
0724:  MOVWF  78
0725:  CLRF   77
0726:  DECFSZ 77,F
0727:  GOTO   726
0728:  DECFSZ 78,F
0729:  GOTO   725
072A:  MOVLW  4A
072B:  MOVWF  77
072C:  DECFSZ 77,F
072D:  GOTO   72C
072E:  GOTO   72F
072F:  DECFSZ 00,F
0730:  GOTO   723
....................  
.................... #use rs232(baud=9600, parity=N, xmit=PIN_C6, rcv=PIN_C7, bits=8) 
.................... #use standard_io(B)  
.................... #use standard_io(A) 
....................  
....................  
.................... #define LCD_ENABLE_PIN  PIN_B3 
.................... #define LCD_RS_PIN      PIN_B1 
.................... #define LCD_RW_PIN      PIN_B2 
.................... #define LCD_DATA4       PIN_B4 
.................... #define LCD_DATA5       PIN_B5 
.................... #define LCD_DATA6       PIN_B6 
.................... #define LCD_DATA7       PIN_B7 
.................... #include<LCD.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00A4:  BSF    06.4
....................    output_float(LCD_DATA5); 
00A5:  BSF    06.5
....................    output_float(LCD_DATA6); 
00A6:  BSF    06.6
....................    output_float(LCD_DATA7); 
00A7:  BSF    06.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00A8:  BCF    03.5
00A9:  BSF    06.2
00AA:  BSF    03.5
00AB:  BCF    06.2
....................    delay_cycles(1); 
00AC:  NOP
....................    lcd_output_enable(1); 
00AD:  BCF    03.5
00AE:  BSF    06.3
00AF:  BSF    03.5
00B0:  BCF    06.3
....................    delay_cycles(1); 
00B1:  NOP
....................    high = lcd_read_nibble(); 
*
00E3:  MOVF   78,W
00E4:  MOVWF  59
....................        
....................    lcd_output_enable(0); 
00E5:  BCF    06.3
00E6:  BSF    03.5
00E7:  BCF    06.3
....................    delay_cycles(1); 
00E8:  NOP
....................    lcd_output_enable(1); 
00E9:  BCF    03.5
00EA:  BSF    06.3
00EB:  BSF    03.5
00EC:  BCF    06.3
....................    delay_us(1); 
00ED:  NOP
....................    low = lcd_read_nibble(); 
*
011F:  MOVF   78,W
0120:  MOVWF  58
....................        
....................    lcd_output_enable(0); 
0121:  BCF    06.3
0122:  BSF    03.5
0123:  BCF    06.3
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0124:  BCF    06.4
....................    output_drive(LCD_DATA5); 
0125:  BCF    06.5
....................    output_drive(LCD_DATA6); 
0126:  BCF    06.6
....................    output_drive(LCD_DATA7); 
0127:  BCF    06.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0128:  BCF    03.5
0129:  SWAPF  59,W
012A:  MOVWF  77
012B:  MOVLW  F0
012C:  ANDWF  77,F
012D:  MOVF   77,W
012E:  IORWF  58,W
012F:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00B2:  BCF    03.5
00B3:  CLRF   5A
*
00EE:  BCF    03.5
00EF:  CLRF   5A
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
00B4:  BSF    03.5
00B5:  BSF    06.4
00B6:  MOVLW  00
00B7:  BCF    03.5
00B8:  BTFSC  06.4
00B9:  MOVLW  01
00BA:  IORWF  5A,F
*
00F0:  BSF    03.5
00F1:  BSF    06.4
00F2:  MOVLW  00
00F3:  BCF    03.5
00F4:  BTFSC  06.4
00F5:  MOVLW  01
00F6:  IORWF  5A,F
....................    n |= input(LCD_DATA5) << 1; 
*
00BB:  BSF    03.5
00BC:  BSF    06.5
00BD:  MOVLW  00
00BE:  BCF    03.5
00BF:  BTFSC  06.5
00C0:  MOVLW  01
00C1:  MOVWF  77
00C2:  BCF    03.0
00C3:  RLF    77,F
00C4:  MOVF   77,W
00C5:  IORWF  5A,F
*
00F7:  BSF    03.5
00F8:  BSF    06.5
00F9:  MOVLW  00
00FA:  BCF    03.5
00FB:  BTFSC  06.5
00FC:  MOVLW  01
00FD:  MOVWF  77
00FE:  BCF    03.0
00FF:  RLF    77,F
0100:  MOVF   77,W
0101:  IORWF  5A,F
....................    n |= input(LCD_DATA6) << 2; 
*
00C6:  BSF    03.5
00C7:  BSF    06.6
00C8:  MOVLW  00
00C9:  BCF    03.5
00CA:  BTFSC  06.6
00CB:  MOVLW  01
00CC:  MOVWF  77
00CD:  RLF    77,F
00CE:  RLF    77,F
00CF:  MOVLW  FC
00D0:  ANDWF  77,F
00D1:  MOVF   77,W
00D2:  IORWF  5A,F
*
0102:  BSF    03.5
0103:  BSF    06.6
0104:  MOVLW  00
0105:  BCF    03.5
0106:  BTFSC  06.6
0107:  MOVLW  01
0108:  MOVWF  77
0109:  RLF    77,F
010A:  RLF    77,F
010B:  MOVLW  FC
010C:  ANDWF  77,F
010D:  MOVF   77,W
010E:  IORWF  5A,F
....................    n |= input(LCD_DATA7) << 3; 
*
00D3:  BSF    03.5
00D4:  BSF    06.7
00D5:  MOVLW  00
00D6:  BCF    03.5
00D7:  BTFSC  06.7
00D8:  MOVLW  01
00D9:  MOVWF  77
00DA:  RLF    77,F
00DB:  RLF    77,F
00DC:  RLF    77,F
00DD:  MOVLW  F8
00DE:  ANDWF  77,F
00DF:  MOVF   77,W
00E0:  IORWF  5A,F
*
010F:  BSF    03.5
0110:  BSF    06.7
0111:  MOVLW  00
0112:  BCF    03.5
0113:  BTFSC  06.7
0114:  MOVLW  01
0115:  MOVWF  77
0116:  RLF    77,F
0117:  RLF    77,F
0118:  RLF    77,F
0119:  MOVLW  F8
011A:  ANDWF  77,F
011B:  MOVF   77,W
011C:  IORWF  5A,F
....................     
....................    return(n); 
*
00E1:  MOVF   5A,W
00E2:  MOVWF  78
*
011D:  MOVF   5A,W
011E:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0071:  BTFSC  59.0
0072:  GOTO   075
0073:  BCF    06.4
0074:  GOTO   076
0075:  BSF    06.4
0076:  BSF    03.5
0077:  BCF    06.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0078:  BCF    03.5
0079:  BTFSC  59.1
007A:  GOTO   07D
007B:  BCF    06.5
007C:  GOTO   07E
007D:  BSF    06.5
007E:  BSF    03.5
007F:  BCF    06.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0080:  BCF    03.5
0081:  BTFSC  59.2
0082:  GOTO   085
0083:  BCF    06.6
0084:  GOTO   086
0085:  BSF    06.6
0086:  BSF    03.5
0087:  BCF    06.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0088:  BCF    03.5
0089:  BTFSC  59.3
008A:  GOTO   08D
008B:  BCF    06.7
008C:  GOTO   08E
008D:  BSF    06.7
008E:  BSF    03.5
008F:  BCF    06.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0090:  NOP
....................    lcd_output_enable(1); 
0091:  BCF    03.5
0092:  BSF    06.3
0093:  BSF    03.5
0094:  BCF    06.3
....................    delay_us(2); 
0095:  GOTO   096
....................    lcd_output_enable(0); 
0096:  BCF    03.5
0097:  BCF    06.3
0098:  BSF    03.5
0099:  BCF    06.3
009A:  BCF    03.5
009B:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
009C:  BSF    03.5
009D:  BCF    06.3
....................    lcd_rs_tris(); 
009E:  BCF    06.1
....................    lcd_rw_tris(); 
009F:  BCF    06.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00A0:  BCF    03.5
00A1:  BCF    06.1
00A2:  BSF    03.5
00A3:  BCF    06.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0130:  MOVF   78,W
0131:  MOVWF  58
0132:  BTFSS  58.7
0133:  GOTO   136
0134:  BSF    03.5
0135:  GOTO   0A4
....................    lcd_output_rs(address); 
0136:  MOVF   56,F
0137:  BTFSS  03.2
0138:  GOTO   13B
0139:  BCF    06.1
013A:  GOTO   13C
013B:  BSF    06.1
013C:  BSF    03.5
013D:  BCF    06.1
....................    delay_cycles(1); 
013E:  NOP
....................    lcd_output_rw(0); 
013F:  BCF    03.5
0140:  BCF    06.2
0141:  BSF    03.5
0142:  BCF    06.2
....................    delay_cycles(1); 
0143:  NOP
....................    lcd_output_enable(0); 
0144:  BCF    03.5
0145:  BCF    06.3
0146:  BSF    03.5
0147:  BCF    06.3
....................    lcd_send_nibble(n >> 4); 
0148:  BCF    03.5
0149:  SWAPF  57,W
014A:  MOVWF  58
014B:  MOVLW  0F
014C:  ANDWF  58,F
014D:  MOVF   58,W
014E:  MOVWF  59
014F:  CALL   071
....................    lcd_send_nibble(n & 0xf); 
0150:  MOVF   57,W
0151:  ANDLW  0F
0152:  MOVWF  58
0153:  MOVWF  59
0154:  CALL   071
0155:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
*
03B8:  MOVLW  28
03B9:  MOVWF  34
03BA:  MOVLW  0C
03BB:  MOVWF  35
03BC:  MOVLW  01
03BD:  MOVWF  36
03BE:  MOVLW  06
03BF:  MOVWF  37
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
03C0:  BCF    06.3
03C1:  BSF    03.5
03C2:  BCF    06.3
....................    lcd_output_rs(0); 
03C3:  BCF    03.5
03C4:  BCF    06.1
03C5:  BSF    03.5
03C6:  BCF    06.1
....................    lcd_output_rw(0); 
03C7:  BCF    03.5
03C8:  BCF    06.2
03C9:  BSF    03.5
03CA:  BCF    06.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
03CB:  BCF    06.4
....................    output_drive(LCD_DATA5); 
03CC:  BCF    06.5
....................    output_drive(LCD_DATA6); 
03CD:  BCF    06.6
....................    output_drive(LCD_DATA7); 
03CE:  BCF    06.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
03CF:  BCF    06.3
....................    lcd_rs_tris(); 
03D0:  BCF    06.1
....................    lcd_rw_tris(); 
03D1:  BCF    06.2
....................  #endif 
....................      
....................    delay_ms(15); 
03D2:  MOVLW  0F
03D3:  BCF    03.5
03D4:  MOVWF  52
....................    for(i=1;i<=3;++i) 
*
03E9:  MOVLW  01
03EA:  MOVWF  33
03EB:  MOVF   33,W
03EC:  SUBLW  03
03ED:  BTFSS  03.0
03EE:  GOTO   410
03EF:  CLRF   2B
03F0:  BTFSC  0B.7
03F1:  BSF    2B.7
03F2:  BCF    0B.7
....................    { 
....................        lcd_send_nibble(3); 
03F3:  MOVLW  03
03F4:  MOVWF  59
03F5:  CALL   071
03F6:  BTFSC  2B.7
03F7:  BSF    0B.7
....................        delay_ms(5); 
03F8:  MOVLW  05
03F9:  MOVWF  52
*
040E:  INCF   33,F
040F:  GOTO   3EB
0410:  CLRF   2B
0411:  BTFSC  0B.7
0412:  BSF    2B.7
0413:  BCF    0B.7
....................    } 
....................     
....................    lcd_send_nibble(2); 
0414:  MOVLW  02
0415:  MOVWF  59
0416:  CALL   071
0417:  BTFSC  2B.7
0418:  BSF    0B.7
....................    delay_ms(5); 
0419:  MOVLW  05
041A:  MOVWF  52
....................    for(i=0;i<=3;++i) 
*
042F:  CLRF   33
0430:  MOVF   33,W
0431:  SUBLW  03
0432:  BTFSS  03.0
0433:  GOTO   446
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0434:  MOVLW  34
0435:  ADDWF  33,W
0436:  MOVWF  04
0437:  BCF    03.7
0438:  MOVF   00,W
0439:  MOVWF  38
043A:  CLRF   2B
043B:  BTFSC  0B.7
043C:  BSF    2B.7
043D:  BCF    0B.7
043E:  CLRF   56
043F:  MOVF   38,W
0440:  MOVWF  57
0441:  CALL   09C
0442:  BTFSC  2B.7
0443:  BSF    0B.7
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0444:  INCF   33,F
0445:  GOTO   430
0446:  BCF    0A.3
0447:  BCF    0A.4
0448:  GOTO   4AF (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0167:  DECFSZ 53,W
0168:  GOTO   16A
0169:  GOTO   16D
*
0198:  DECFSZ 53,W
0199:  GOTO   19B
019A:  GOTO   19E
....................       address=LCD_LINE_TWO; 
*
016A:  MOVLW  40
016B:  MOVWF  54
016C:  GOTO   16E
*
019B:  MOVLW  40
019C:  MOVWF  54
019D:  GOTO   19F
....................    else 
....................       address=0; 
*
016D:  CLRF   54
*
019E:  CLRF   54
....................       
....................    address+=x-1; 
*
016E:  MOVLW  01
016F:  SUBWF  52,W
0170:  ADDWF  54,F
*
019F:  MOVLW  01
01A0:  SUBWF  52,W
01A1:  ADDWF  54,F
....................    lcd_send_byte(0,0x80|address); 
*
0171:  MOVF   54,W
0172:  IORLW  80
0173:  MOVWF  55
0174:  CLRF   56
0175:  MOVF   55,W
0176:  MOVWF  57
0177:  CALL   09C
*
01A2:  MOVF   54,W
01A3:  IORLW  80
01A4:  MOVWF  55
01A5:  CLRF   56
01A6:  MOVF   55,W
01A7:  MOVWF  57
01A8:  CALL   09C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
0156:  MOVF   51,W
0157:  XORLW  07
0158:  BTFSC  03.2
0159:  GOTO   164
015A:  XORLW  0B
015B:  BTFSC  03.2
015C:  GOTO   179
015D:  XORLW  06
015E:  BTFSC  03.2
015F:  GOTO   194
0160:  XORLW  02
0161:  BTFSC  03.2
0162:  GOTO   1AA
0163:  GOTO   1AF
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0164:  MOVLW  01
0165:  MOVWF  52
0166:  MOVWF  53
*
0178:  GOTO   1B4
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0179:  CLRF   56
017A:  MOVLW  01
017B:  MOVWF  57
017C:  CALL   09C
....................                      delay_ms(2); 
017D:  MOVLW  02
017E:  MOVWF  52
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
*
0193:  GOTO   1B4
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0194:  MOVLW  01
0195:  MOVWF  52
0196:  MOVLW  02
0197:  MOVWF  53
*
01A9:  GOTO   1B4
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01AA:  CLRF   56
01AB:  MOVLW  10
01AC:  MOVWF  57
01AD:  CALL   09C
01AE:  GOTO   1B4
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01AF:  MOVLW  01
01B0:  MOVWF  56
01B1:  MOVF   51,W
01B2:  MOVWF  57
01B3:  CALL   09C
....................      #endif 
....................    } 
01B4:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include<stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
04AA:  BCF    03.6
04AB:  CLRF   2C
04AC:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... int32 count = 0; 
.................... char valor; 
....................  
.................... void stop() { 
....................     disable_interrupts(INT_TIMER1); 
*
005F:  BSF    03.5
0060:  BCF    0C.0
....................     output_low(PIN_A3); 
0061:  BCF    05.3
0062:  BCF    03.5
0063:  BCF    05.3
....................     output_low(PIN_A4); 
0064:  BSF    03.5
0065:  BCF    05.4
0066:  BCF    03.5
0067:  BCF    05.4
....................     output_low(PIN_A5); 
0068:  BSF    03.5
0069:  BCF    05.5
006A:  BCF    03.5
006B:  BCF    05.5
....................     output_low(PIN_A6); 
006C:  BSF    03.5
006D:  BCF    05.6
006E:  BCF    03.5
006F:  BCF    05.6
0070:  RETURN
.................... } 
....................  
.................... #INT_EXT 
....................  
.................... void isr_ext() { 
....................     stop(); 
*
025A:  CALL   05F
....................     lcd_putc("\fGame Over\n"); 
025B:  MOVLW  64
025C:  BSF    03.6
025D:  MOVWF  0D
025E:  MOVLW  03
025F:  MOVWF  0F
0260:  BCF    03.6
0261:  CALL   1B5
....................     printf(lcd_putc, "Score: %lu", count * 10); 
0262:  MOVF   31,W
0263:  MOVWF  44
0264:  MOVF   30,W
0265:  MOVWF  43
0266:  MOVF   2F,W
0267:  MOVWF  42
0268:  MOVF   2E,W
0269:  MOVWF  41
026A:  CLRF   48
026B:  CLRF   47
026C:  CLRF   46
026D:  MOVLW  0A
026E:  MOVWF  45
*
0298:  MOVF   7A,W
0299:  MOVWF  44
029A:  MOVF   79,W
029B:  MOVWF  43
029C:  MOVF   78,W
029D:  MOVWF  42
029E:  MOVF   77,W
029F:  MOVWF  41
02A0:  MOVLW  6A
02A1:  BSF    03.6
02A2:  MOVWF  0D
02A3:  MOVLW  03
02A4:  MOVWF  0F
02A5:  BCF    03.0
02A6:  MOVLW  07
02A7:  BCF    03.6
02A8:  MOVWF  45
*
02FF:  MOVLW  41
0300:  MOVWF  04
0301:  MOVF   44,W
0302:  MOVWF  48
0303:  MOVF   43,W
0304:  MOVWF  47
0305:  MOVF   42,W
0306:  MOVWF  46
0307:  MOVF   41,W
0308:  MOVWF  45
....................     while (1); 
*
035F:  GOTO   35F
.................... } 
....................  
0360:  BCF    0B.1
0361:  BCF    0A.3
0362:  BCF    0A.4
0363:  GOTO   035
.................... #INT_TIMER0 
....................  
.................... void isr_timer0() { 
....................     set_timer0(178); 
*
0370:  MOVLW  B2
0371:  MOVWF  01
....................     output_toggle(PIN_A7); 
0372:  BSF    03.5
0373:  BCF    05.7
0374:  MOVLW  80
0375:  BCF    03.5
0376:  XORWF  05,F
.................... } 
....................  
0377:  BCF    0B.2
0378:  BCF    0A.3
0379:  BCF    0A.4
037A:  GOTO   035
.................... #INT_TIMER1 
....................  
.................... void isr_timer1() { 
....................     set_timer1(3035); 
037B:  CLRF   0E
037C:  MOVLW  0B
037D:  MOVWF  0F
037E:  MOVLW  DB
037F:  MOVWF  0E
....................     count++; 
0380:  MOVLW  01
0381:  ADDWF  2E,F
0382:  BTFSC  03.0
0383:  INCF   2F,F
0384:  BTFSC  03.2
0385:  INCF   30,F
0386:  BTFSC  03.2
0387:  INCF   31,F
0388:  BCF    0C.0
0389:  BCF    0A.3
038A:  BCF    0A.4
038B:  GOTO   035
.................... } 
....................  
.................... void Adelante() { 
....................     enable_interrupts(INT_TIMER1); 
*
0510:  BSF    03.5
0511:  BSF    0C.0
....................     printf("Adelante\n\n"); 
0512:  MOVLW  8C
0513:  BCF    03.5
0514:  BSF    03.6
0515:  MOVWF  0D
0516:  MOVLW  03
0517:  MOVWF  0F
....................     lcd_putc("\fAdelante"); 
*
056D:  MOVLW  92
056E:  MOVWF  0D
056F:  MOVLW  03
0570:  MOVWF  0F
0571:  BCF    03.6
0572:  CLRF   2B
0573:  BTFSC  0B.7
0574:  BSF    2B.7
0575:  BCF    0B.7
0576:  CALL   1B5
0577:  BTFSC  2B.7
0578:  BSF    0B.7
....................     output_high(PIN_A4); 
0579:  BSF    03.5
057A:  BCF    05.4
057B:  BCF    03.5
057C:  BSF    05.4
....................     output_high(PIN_A6); 
057D:  BSF    03.5
057E:  BCF    05.6
057F:  BCF    03.5
0580:  BSF    05.6
....................     delay_ms(100); 
0581:  MOVLW  64
0582:  MOVWF  52
.................... } 
....................  
.................... void Atras() { 
....................     enable_interrupts(INT_TIMER1); 
*
0598:  BSF    03.5
0599:  BSF    0C.0
....................     printf("Atras\n\n"); 
059A:  MOVLW  97
059B:  BCF    03.5
059C:  BSF    03.6
059D:  MOVWF  0D
059E:  MOVLW  03
059F:  MOVWF  0F
....................     lcd_putc("\fAtras"); 
*
05F5:  MOVLW  9B
05F6:  MOVWF  0D
05F7:  MOVLW  03
05F8:  MOVWF  0F
05F9:  BCF    03.6
05FA:  CLRF   2B
05FB:  BTFSC  0B.7
05FC:  BSF    2B.7
05FD:  BCF    0B.7
05FE:  CALL   1B5
05FF:  BTFSC  2B.7
0600:  BSF    0B.7
....................     output_high(PIN_A3); 
0601:  BSF    03.5
0602:  BCF    05.3
0603:  BCF    03.5
0604:  BSF    05.3
....................     output_high(PIN_A5); 
0605:  BSF    03.5
0606:  BCF    05.5
0607:  BCF    03.5
0608:  BSF    05.5
....................     delay_ms(100); 
0609:  MOVLW  64
060A:  MOVWF  52
.................... } 
....................  
.................... void Derecha() { 
....................     enable_interrupts(INT_TIMER1); 
*
0620:  BSF    03.5
0621:  BSF    0C.0
....................     printf("Derecha\n\n"); 
0622:  MOVLW  9F
0623:  BCF    03.5
0624:  BSF    03.6
0625:  MOVWF  0D
0626:  MOVLW  03
0627:  MOVWF  0F
....................     lcd_putc("\fDerecha"); 
*
067D:  MOVLW  A4
067E:  MOVWF  0D
067F:  MOVLW  03
0680:  MOVWF  0F
0681:  BCF    03.6
0682:  CLRF   2B
0683:  BTFSC  0B.7
0684:  BSF    2B.7
0685:  BCF    0B.7
0686:  CALL   1B5
0687:  BTFSC  2B.7
0688:  BSF    0B.7
....................     output_high(PIN_A3); 
0689:  BSF    03.5
068A:  BCF    05.3
068B:  BCF    03.5
068C:  BSF    05.3
....................     output_high(PIN_A6); 
068D:  BSF    03.5
068E:  BCF    05.6
068F:  BCF    03.5
0690:  BSF    05.6
....................     delay_ms(100); 
0691:  MOVLW  64
0692:  MOVWF  52
.................... } 
....................  
.................... void izquierda() { 
....................     printf("\n\nIzquierda\n\n"); 
*
06A8:  MOVLW  A9
06A9:  BSF    03.6
06AA:  MOVWF  0D
06AB:  MOVLW  03
06AC:  MOVWF  0F
....................     enable_interrupts(INT_TIMER1); 
*
0702:  BSF    03.5
0703:  BCF    03.6
0704:  BSF    0C.0
....................     lcd_putc("\fIzquierda"); 
0705:  MOVLW  B0
0706:  BCF    03.5
0707:  BSF    03.6
0708:  MOVWF  0D
0709:  MOVLW  03
070A:  MOVWF  0F
070B:  BCF    03.6
070C:  CLRF   2B
070D:  BTFSC  0B.7
070E:  BSF    2B.7
070F:  BCF    0B.7
0710:  CALL   1B5
0711:  BTFSC  2B.7
0712:  BSF    0B.7
....................     output_high(PIN_A4); 
0713:  BSF    03.5
0714:  BCF    05.4
0715:  BCF    03.5
0716:  BSF    05.4
....................     output_high(PIN_A5); 
0717:  BSF    03.5
0718:  BCF    05.5
0719:  BCF    03.5
071A:  BSF    05.5
....................     delay_ms(100); 
071B:  MOVLW  64
071C:  MOVWF  52
.................... } 
....................  
.................... void main() { 
*
0485:  MOVF   03,W
0486:  ANDLW  1F
0487:  MOVWF  03
0488:  MOVLW  61
0489:  BSF    03.5
048A:  MOVWF  0F
048B:  MOVF   0F,W
048C:  BSF    03.6
048D:  BCF    07.3
048E:  MOVLW  19
048F:  BCF    03.6
0490:  MOVWF  19
0491:  MOVLW  A6
0492:  MOVWF  18
0493:  MOVLW  90
0494:  BCF    03.5
0495:  MOVWF  18
0496:  CLRF   31
0497:  CLRF   30
0498:  CLRF   2F
0499:  CLRF   2E
049A:  BSF    03.5
049B:  BSF    03.6
049C:  MOVF   09,W
049D:  ANDLW  C0
049E:  MOVWF  09
049F:  BCF    03.6
04A0:  BCF    1F.4
04A1:  BCF    1F.5
04A2:  MOVLW  00
04A3:  BSF    03.6
04A4:  MOVWF  08
04A5:  BCF    03.5
04A6:  CLRF   07
04A7:  CLRF   08
04A8:  CLRF   09
04A9:  BCF    03.7
....................     stop(); 
*
04AD:  CALL   05F
....................     lcd_init(); 
04AE:  GOTO   3B8
....................     lcd_putc("\f"); 
04AF:  MOVLW  B6
04B0:  BSF    03.6
04B1:  MOVWF  0D
04B2:  MOVLW  03
04B3:  MOVWF  0F
04B4:  BCF    03.6
04B5:  CLRF   2B
04B6:  BTFSC  0B.7
04B7:  BSF    2B.7
04B8:  BCF    0B.7
04B9:  CALL   1B5
04BA:  BTFSC  2B.7
04BB:  BSF    0B.7
....................     port_b_pullups(1); 
04BC:  MOVLW  01
04BD:  BSF    03.5
04BE:  MOVWF  15
04BF:  BCF    01.7
....................     enable_interrupts(GLOBAL); 
04C0:  MOVLW  C0
04C1:  BCF    03.5
04C2:  IORWF  0B,F
....................     enable_interrupts(INT_TIMER0); 
04C3:  BSF    0B.5
....................     disable_interrupts(INT_TIMER1); 
04C4:  BSF    03.5
04C5:  BCF    0C.0
....................     enable_interrupts(INT_EXT_H2L); 
04C6:  BCF    03.5
04C7:  BSF    0B.4
04C8:  BSF    03.5
04C9:  BCF    01.6
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256); 
04CA:  MOVF   01,W
04CB:  ANDLW  C0
04CC:  IORLW  07
04CD:  MOVWF  01
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
04CE:  MOVLW  35
04CF:  BCF    03.5
04D0:  MOVWF  10
....................     set_timer0(178); 
04D1:  MOVLW  B2
04D2:  MOVWF  01
....................     set_timer1(3035); 
04D3:  CLRF   0E
04D4:  MOVLW  0B
04D5:  MOVWF  0F
04D6:  MOVLW  DB
04D7:  MOVWF  0E
....................     setup_uart(9600); 
04D8:  BSF    03.5
04D9:  BSF    03.6
04DA:  BCF    07.3
04DB:  MOVLW  19
04DC:  BCF    03.6
04DD:  MOVWF  19
04DE:  MOVLW  A6
04DF:  MOVWF  18
04E0:  MOVLW  90
04E1:  BCF    03.5
04E2:  MOVWF  18
....................     while (1) { 
....................         while (kbhit()); 
04E3:  BTFSC  0C.5
04E4:  GOTO   4E3
....................         lcd_putc("\f"); 
04E5:  MOVLW  B7
04E6:  BSF    03.6
04E7:  MOVWF  0D
04E8:  MOVLW  03
04E9:  MOVWF  0F
04EA:  BCF    03.6
04EB:  CLRF   2B
04EC:  BTFSC  0B.7
04ED:  BSF    2B.7
04EE:  BCF    0B.7
04EF:  CALL   1B5
04F0:  BTFSC  2B.7
04F1:  BSF    0B.7
....................         stop(); 
04F2:  CALL   05F
....................         scanf("%c", &valor); 
04F3:  CLRF   33
04F4:  CLRF   34
04F5:  MOVLW  32
04F6:  MOVWF  35
04F7:  CLRF   37
04F8:  CLRF   36
04F9:  GOTO   449
04FA:  MOVF   78,F
04FB:  BTFSS  03.2
04FC:  GOTO   4FF
04FD:  CLRF   34
04FE:  GOTO   502
04FF:  MOVF   78,W
0500:  ADDWF  33,F
0501:  INCF   34,F
....................         switch (valor) { 
0502:  MOVF   32,W
0503:  XORLW  57
0504:  BTFSC  03.2
0505:  GOTO   510
0506:  XORLW  04
0507:  BTFSC  03.2
0508:  GOTO   598
0509:  XORLW  17
050A:  BTFSC  03.2
050B:  GOTO   620
050C:  XORLW  05
050D:  BTFSC  03.2
050E:  GOTO   6A8
050F:  GOTO   732
....................             case 'W': 
....................                 Adelante(); 
....................                 break; 
*
0597:  GOTO   733
....................             case 'S': 
....................                 Atras(); 
....................                 break; 
*
061F:  GOTO   733
....................             case 'D': 
....................                 Derecha(); 
....................                 break; 
*
06A7:  GOTO   733
....................             case 'A': 
....................                 Izquierda(); 
....................                 break; 
*
0731:  GOTO   733
....................             default: 
....................                 stop(); 
0732:  CALL   05F
....................                 break; 
....................         } 
0733:  GOTO   4E3
....................     } 
.................... } 
0734:  SLEEP

Configuration Fuses:
   Word  1: 2FE4   INTRC_IO NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
