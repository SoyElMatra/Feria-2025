CCS PCM C Compiler, Version 5.015, 5967               22-ago.-24 12:40

               Filename:   H:\Mi unidad\Feria 2024\MPLAB\Feria.X\build\default\production\Fantasma+.lst

               ROM used:   1022 words (12%)
                           Largest free fragment is 2048
               RAM used:   28 (8%) at main() level
                           36 (10%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   2E8
0003:  NOP
.................... #include <16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
0004:  DATA 0A,05
0005:  DATA 41,32
0006:  DATA 65,36
0007:  DATA 61,37
0008:  DATA F4,32
0009:  DATA 0A,05
000A:  DATA 00,00
000B:  DATA 0A,05
000C:  DATA C4,32
000D:  DATA F2,32
000E:  DATA 63,34
000F:  DATA 61,05
0010:  DATA 0A,00
0011:  DATA 0A,05
0012:  DATA 49,3D
0013:  DATA F1,3A
0014:  DATA E9,32
0015:  DATA 72,32
0016:  DATA 61,05
0017:  DATA 0A,00
0018:  DATA 8A,20
0019:  DATA E4,32
001A:  DATA EC,30
001B:  DATA 6E,3A
001C:  DATA 65,1D
001D:  DATA A0,12
001E:  DATA EC,3A
001F:  DATA A0,31
0020:  DATA 6D,05
0021:  DATA 00,00
0022:  DATA 0A,22
0023:  DATA 65,39
0024:  DATA E5,31
0025:  DATA E8,30
0026:  DATA 3A,10
0027:  DATA 25,36
0028:  DATA 75,10
0029:  DATA E3,36
002A:  DATA 0A,00
002B:  DATA 8A,24
002C:  DATA FA,38
002D:  DATA F5,34
002E:  DATA 65,39
002F:  DATA E4,30
0030:  DATA 3A,10
0031:  DATA 25,36
0032:  DATA 75,10
0033:  DATA E3,36
0034:  DATA 0A,05
0035:  DATA 0A,00
*
0047:  CLRF   78
0048:  CLRF   79
0049:  CLRF   77
004A:  CLRF   7A
004B:  MOVF   39,W
004C:  BTFSS  03.2
004D:  GOTO   051
004E:  MOVF   38,W
004F:  BTFSC  03.2
0050:  GOTO   06B
0051:  MOVLW  10
0052:  MOVWF  3A
0053:  BCF    03.0
0054:  RLF    36,F
0055:  RLF    37,F
0056:  RLF    77,F
0057:  RLF    7A,F
0058:  MOVF   39,W
0059:  SUBWF  7A,W
005A:  BTFSS  03.2
005B:  GOTO   05E
005C:  MOVF   38,W
005D:  SUBWF  77,W
005E:  BTFSS  03.0
005F:  GOTO   067
0060:  MOVF   38,W
0061:  SUBWF  77,F
0062:  BTFSS  03.0
0063:  DECF   7A,F
0064:  MOVF   39,W
0065:  SUBWF  7A,F
0066:  BSF    03.0
0067:  RLF    78,F
0068:  RLF    79,F
0069:  DECFSZ 3A,F
006A:  GOTO   053
006B:  RETURN
*
0164:  MOVF   0B,W
0165:  MOVWF  36
0166:  BCF    0B.7
0167:  BSF    03.5
0168:  BSF    03.6
0169:  BSF    0C.7
016A:  BSF    0C.0
016B:  NOP
016C:  NOP
016D:  BCF    03.5
016E:  BCF    03.6
016F:  BTFSC  36.7
0170:  BSF    0B.7
0171:  BSF    03.6
0172:  MOVF   0C,W
0173:  ANDLW  7F
0174:  BTFSC  03.2
0175:  GOTO   1BA
0176:  BCF    03.6
0177:  MOVWF  36
0178:  BSF    03.6
0179:  MOVF   0D,W
017A:  BCF    03.6
017B:  MOVWF  37
017C:  BSF    03.6
017D:  MOVF   0F,W
017E:  BCF    03.6
017F:  MOVWF  38
0180:  MOVF   36,W
0181:  BTFSS  0C.4
0182:  GOTO   181
0183:  MOVWF  19
0184:  MOVF   37,W
0185:  BSF    03.6
0186:  MOVWF  0D
0187:  BCF    03.6
0188:  MOVF   38,W
0189:  BSF    03.6
018A:  MOVWF  0F
018B:  BCF    03.6
018C:  MOVF   0B,W
018D:  MOVWF  39
018E:  BCF    0B.7
018F:  BSF    03.5
0190:  BSF    03.6
0191:  BSF    0C.7
0192:  BSF    0C.0
0193:  NOP
0194:  NOP
0195:  BCF    03.5
0196:  BCF    03.6
0197:  BTFSC  39.7
0198:  BSF    0B.7
0199:  BSF    03.6
019A:  RLF    0C,W
019B:  RLF    0E,W
019C:  ANDLW  7F
019D:  BTFSC  03.2
019E:  GOTO   1BA
019F:  BCF    03.6
01A0:  MOVWF  36
01A1:  BSF    03.6
01A2:  MOVF   0D,W
01A3:  BCF    03.6
01A4:  MOVWF  37
01A5:  BSF    03.6
01A6:  MOVF   0F,W
01A7:  BCF    03.6
01A8:  MOVWF  38
01A9:  MOVF   36,W
01AA:  BTFSS  0C.4
01AB:  GOTO   1AA
01AC:  MOVWF  19
01AD:  MOVF   37,W
01AE:  BSF    03.6
01AF:  MOVWF  0D
01B0:  BCF    03.6
01B1:  MOVF   38,W
01B2:  BSF    03.6
01B3:  MOVWF  0F
01B4:  INCF   0D,F
01B5:  BTFSC  03.2
01B6:  INCF   0F,F
01B7:  BCF    03.6
01B8:  GOTO   164
01B9:  BSF    03.6
01BA:  BCF    03.6
01BB:  RETURN
*
0236:  MOVF   0B,W
0237:  MOVWF  37
0238:  BCF    0B.7
0239:  BSF    03.5
023A:  BSF    03.6
023B:  BSF    0C.7
023C:  BSF    0C.0
023D:  NOP
023E:  NOP
023F:  BCF    03.5
0240:  BCF    03.6
0241:  BTFSC  37.7
0242:  BSF    0B.7
0243:  BTFSC  03.0
0244:  GOTO   26E
0245:  BSF    03.6
0246:  MOVF   0C,W
0247:  ANDLW  7F
0248:  BCF    03.6
0249:  MOVWF  37
024A:  BSF    03.6
024B:  MOVF   0D,W
024C:  BCF    03.6
024D:  MOVWF  38
024E:  BSF    03.6
024F:  MOVF   0F,W
0250:  BCF    03.6
0251:  MOVWF  39
0252:  MOVF   37,W
0253:  BTFSS  0C.4
0254:  GOTO   253
0255:  MOVWF  19
0256:  MOVF   38,W
0257:  BSF    03.6
0258:  MOVWF  0D
0259:  BCF    03.6
025A:  MOVF   39,W
025B:  BSF    03.6
025C:  MOVWF  0F
025D:  BCF    03.6
025E:  MOVF   0B,W
025F:  MOVWF  3A
0260:  BCF    0B.7
0261:  BSF    03.5
0262:  BSF    03.6
0263:  BSF    0C.7
0264:  BSF    0C.0
0265:  NOP
0266:  NOP
0267:  BCF    03.5
0268:  BCF    03.6
0269:  BTFSC  3A.7
026A:  BSF    0B.7
026B:  DECFSZ 36,F
026C:  GOTO   26E
026D:  GOTO   28E
026E:  BSF    03.6
026F:  RLF    0C,W
0270:  RLF    0E,W
0271:  ANDLW  7F
0272:  BCF    03.6
0273:  MOVWF  37
0274:  BSF    03.6
0275:  MOVF   0D,W
0276:  BCF    03.6
0277:  MOVWF  38
0278:  BSF    03.6
0279:  MOVF   0F,W
027A:  BCF    03.6
027B:  MOVWF  39
027C:  MOVF   37,W
027D:  BTFSS  0C.4
027E:  GOTO   27D
027F:  MOVWF  19
0280:  MOVF   38,W
0281:  BSF    03.6
0282:  MOVWF  0D
0283:  BCF    03.6
0284:  MOVF   39,W
0285:  BSF    03.6
0286:  MOVWF  0F
0287:  INCF   0D,F
0288:  BTFSC  03.2
0289:  INCF   0F,F
028A:  BCF    03.0
028B:  BCF    03.6
028C:  DECFSZ 36,F
028D:  GOTO   236
028E:  RETURN
028F:  CLRF   3E
0290:  MOVF   04,W
0291:  MOVWF  3D
0292:  BCF    3E.0
0293:  BTFSC  03.7
0294:  BSF    3E.0
0295:  SWAPF  37,W
0296:  IORLW  F0
0297:  MOVWF  39
0298:  ADDWF  39,F
0299:  ADDLW  E2
029A:  MOVWF  3A
029B:  ADDLW  32
029C:  MOVWF  3C
029D:  MOVF   37,W
029E:  ANDLW  0F
029F:  ADDWF  3A,F
02A0:  ADDWF  3A,F
02A1:  ADDWF  3C,F
02A2:  ADDLW  E9
02A3:  MOVWF  3B
02A4:  ADDWF  3B,F
02A5:  ADDWF  3B,F
02A6:  SWAPF  36,W
02A7:  ANDLW  0F
02A8:  ADDWF  3B,F
02A9:  ADDWF  3C,F
02AA:  RLF    3B,F
02AB:  RLF    3C,F
02AC:  COMF   3C,F
02AD:  RLF    3C,F
02AE:  MOVF   36,W
02AF:  ANDLW  0F
02B0:  ADDWF  3C,F
02B1:  RLF    39,F
02B2:  MOVLW  07
02B3:  MOVWF  38
02B4:  MOVLW  0A
02B5:  ADDWF  3C,F
02B6:  DECF   3B,F
02B7:  BTFSS  03.0
02B8:  GOTO   2B5
02B9:  ADDWF  3B,F
02BA:  DECF   3A,F
02BB:  BTFSS  03.0
02BC:  GOTO   2B9
02BD:  ADDWF  3A,F
02BE:  DECF   39,F
02BF:  BTFSS  03.0
02C0:  GOTO   2BD
02C1:  ADDWF  39,F
02C2:  DECF   38,F
02C3:  BTFSS  03.0
02C4:  GOTO   2C1
02C5:  MOVLW  38
02C6:  MOVWF  04
02C7:  BCF    03.7
02C8:  MOVLW  07
02C9:  ANDWF  3D,W
02CA:  BCF    3D.6
02CB:  ADDWF  04,F
02CC:  MOVLW  3C
02CD:  SUBWF  04,W
02CE:  BTFSC  03.2
02CF:  BSF    3D.6
02D0:  MOVF   00,W
02D1:  MOVWF  77
02D2:  BTFSS  03.2
02D3:  GOTO   2DC
02D4:  BTFSC  3D.6
02D5:  GOTO   2DC
02D6:  BTFSC  3D.4
02D7:  GOTO   2E4
02D8:  BTFSC  3D.3
02D9:  GOTO   2DC
02DA:  MOVLW  20
02DB:  GOTO   2DF
02DC:  BSF    3D.3
02DD:  BCF    3D.4
02DE:  MOVLW  30
02DF:  ADDWF  77,F
02E0:  MOVF   77,W
02E1:  BTFSS  0C.4
02E2:  GOTO   2E1
02E3:  MOVWF  19
02E4:  INCF   04,F
02E5:  BTFSS  3D.6
02E6:  GOTO   2CC
02E7:  RETURN
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, MCLR, NOWDT, NOLVP 
.................... #use delay(clock = 4M) 
*
01BC:  MOVLW  37
01BD:  MOVWF  04
01BE:  BCF    03.7
01BF:  MOVF   00,W
01C0:  BTFSC  03.2
01C1:  GOTO   1D0
01C2:  MOVLW  01
01C3:  MOVWF  78
01C4:  CLRF   77
01C5:  DECFSZ 77,F
01C6:  GOTO   1C5
01C7:  DECFSZ 78,F
01C8:  GOTO   1C4
01C9:  MOVLW  4A
01CA:  MOVWF  77
01CB:  DECFSZ 77,F
01CC:  GOTO   1CB
01CD:  GOTO   1CE
01CE:  DECFSZ 00,F
01CF:  GOTO   1C2
01D0:  RETURN
....................  
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8) 
.................... #use standard_io(C) 
.................... #use standard_io(B) 
.................... #use standard_io(A) 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0311:  BCF    03.6
0312:  CLRF   21
0313:  CLRF   22
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define TRIGDEL PIN_C0 
.................... #define ECHODEL PIN_C1 
.................... #define TRIGDER PIN_C2 
.................... #define ECHODER PIN_C3 
.................... #define TRIGIZQ PIN_C4 
.................... #define ECHOIZQ PIN_C5 
.................... #define turn 1100 
.................... #define back 2200 
....................  
.................... char posA; 
.................... char posB; 
.................... char valor; 
.................... int check = 0; 
.................... int16 duration; 
.................... int16 turns = turn; 
.................... int1 testprintf = 1; 
.................... int16 distanceDelante; 
.................... int16 distanceDerecha; 
.................... int16 distanceIzquierda; 
....................  
.................... void stop() { 
....................     output_low(PIN_A0); 
*
0036:  BSF    03.5
0037:  BCF    05.0
0038:  BCF    03.5
0039:  BCF    05.0
....................     output_low(PIN_A1); 
003A:  BSF    03.5
003B:  BCF    05.1
003C:  BCF    03.5
003D:  BCF    05.1
....................     output_low(PIN_A2); 
003E:  BSF    03.5
003F:  BCF    05.2
0040:  BCF    03.5
0041:  BCF    05.2
....................     output_low(PIN_A3); 
0042:  BSF    03.5
0043:  BCF    05.3
0044:  BCF    03.5
0045:  BCF    05.3
0046:  RETURN
.................... } 
....................  
.................... void Adelante() { 
....................     if (testprintf == 1) { 
*
01DC:  BTFSS  2F.0
01DD:  GOTO   1E5
....................         printf("\n\nAdelante\n\n"); 
01DE:  MOVLW  04
01DF:  BSF    03.6
01E0:  MOVWF  0D
01E1:  MOVLW  00
01E2:  MOVWF  0F
01E3:  BCF    03.6
01E4:  CALL   164
....................     } 
....................     testprintf = 0; 
01E5:  BCF    2F.0
....................     output_high(PIN_A1); 
01E6:  BSF    03.5
01E7:  BCF    05.1
01E8:  BCF    03.5
01E9:  BSF    05.1
....................     output_high(PIN_A3); 
01EA:  BSF    03.5
01EB:  BCF    05.3
01EC:  BCF    03.5
01ED:  BSF    05.3
....................     delay_ms(100); 
01EE:  MOVLW  64
01EF:  MOVWF  37
01F0:  CALL   1BC
.................... } 
....................  
.................... void Derecha() { 
....................     if (testprintf == 1) { 
*
01F2:  BTFSS  2F.0
01F3:  GOTO   1FB
....................         printf("\n\nDerecha\n\n"); 
01F4:  MOVLW  0B
01F5:  BSF    03.6
01F6:  MOVWF  0D
01F7:  MOVLW  00
01F8:  MOVWF  0F
01F9:  BCF    03.6
01FA:  CALL   164
....................     } 
....................     testprintf = 0; 
01FB:  BCF    2F.0
....................     output_high(PIN_A0); 
01FC:  BSF    03.5
01FD:  BCF    05.0
01FE:  BCF    03.5
01FF:  BSF    05.0
....................     output_high(PIN_A3); 
0200:  BSF    03.5
0201:  BCF    05.3
0202:  BCF    03.5
0203:  BSF    05.3
....................     delay_ms(turns); 
0204:  MOVF   2E,W
0205:  MOVWF  36
0206:  INCF   36,F
0207:  DECF   36,F
0208:  BTFSC  03.2
0209:  GOTO   20E
020A:  MOVLW  FF
020B:  MOVWF  37
020C:  CALL   1BC
020D:  GOTO   207
020E:  MOVF   2D,W
020F:  MOVWF  37
0210:  CALL   1BC
.................... } 
....................  
.................... void izquierda() { 
....................     if (testprintf == 1) { 
*
0212:  BTFSS  2F.0
0213:  GOTO   21B
....................         printf("\n\nIzquierda\n\n"); 
0214:  MOVLW  11
0215:  BSF    03.6
0216:  MOVWF  0D
0217:  MOVLW  00
0218:  MOVWF  0F
0219:  BCF    03.6
021A:  CALL   164
....................     } 
....................     testprintf = 0; 
021B:  BCF    2F.0
....................     output_high(PIN_A1); 
021C:  BSF    03.5
021D:  BCF    05.1
021E:  BCF    03.5
021F:  BSF    05.1
....................     output_high(PIN_A2); 
0220:  BSF    03.5
0221:  BCF    05.2
0222:  BCF    03.5
0223:  BSF    05.2
....................     delay_ms(turns); 
0224:  MOVF   2E,W
0225:  MOVWF  36
0226:  INCF   36,F
0227:  DECF   36,F
0228:  BTFSC  03.2
0229:  GOTO   22E
022A:  MOVLW  FF
022B:  MOVWF  37
022C:  CALL   1BC
022D:  GOTO   227
022E:  MOVF   2D,W
022F:  MOVWF  37
0230:  CALL   1BC
.................... } 
....................  
.................... void action() { 
....................     switch (valor) { 
*
01D1:  MOVF   29,W
01D2:  XORLW  57
01D3:  BTFSC  03.2
01D4:  GOTO   1DC
01D5:  XORLW  13
01D6:  BTFSC  03.2
01D7:  GOTO   1F2
01D8:  XORLW  05
01D9:  BTFSC  03.2
01DA:  GOTO   212
01DB:  GOTO   232
....................         case 'W': 
....................             Adelante(); 
....................             break; 
*
01F1:  GOTO   233
....................         case 'D': 
....................             Derecha(); 
....................             break; 
*
0211:  GOTO   233
....................         case 'A': 
....................             Izquierda(); 
....................             break; 
*
0231:  GOTO   233
....................         default: 
....................             stop(); 
0232:  CALL   036
....................             break; 
....................     } 
0233:  BCF    0A.3
0234:  BCF    0A.4
0235:  GOTO   3A0 (RETURN)
.................... } 
....................  
.................... void sr04distDelante() { 
....................     output_low(TRIGDEL); 
*
006C:  BCF    20.0
006D:  MOVF   20,W
006E:  BSF    03.5
006F:  MOVWF  07
0070:  BCF    03.5
0071:  BCF    07.0
....................     delay_us(2); 
0072:  GOTO   073
....................     output_high(TRIGDEL); 
0073:  BCF    20.0
0074:  MOVF   20,W
0075:  BSF    03.5
0076:  MOVWF  07
0077:  BCF    03.5
0078:  BSF    07.0
....................     delay_us(10); 
0079:  MOVLW  02
007A:  MOVWF  77
007B:  DECFSZ 77,F
007C:  GOTO   07B
007D:  GOTO   07E
007E:  NOP
....................     output_low(TRIGDEL); 
007F:  BCF    20.0
0080:  MOVF   20,W
0081:  BSF    03.5
0082:  MOVWF  07
0083:  BCF    03.5
0084:  BCF    07.0
....................  
....................     set_timer1(0); 
0085:  CLRF   0E
0086:  CLRF   0F
0087:  CLRF   0E
....................     while (!input(ECHODEL)); 
0088:  BSF    20.1
0089:  MOVF   20,W
008A:  BSF    03.5
008B:  MOVWF  07
008C:  BCF    03.5
008D:  BTFSS  07.1
008E:  GOTO   088
....................     set_timer1(0); 
008F:  CLRF   0E
0090:  CLRF   0F
0091:  CLRF   0E
....................     while (input(ECHODEL)); 
0092:  BSF    20.1
0093:  MOVF   20,W
0094:  BSF    03.5
0095:  MOVWF  07
0096:  BCF    03.5
0097:  BTFSC  07.1
0098:  GOTO   092
....................     duration = get_timer1(); 
0099:  MOVF   0F,W
009A:  MOVWF  7A
009B:  MOVF   0E,W
009C:  MOVWF  77
009D:  MOVF   0F,W
009E:  SUBWF  7A,W
009F:  BTFSS  03.2
00A0:  GOTO   099
00A1:  MOVF   77,W
00A2:  MOVWF  2B
00A3:  MOVF   7A,W
00A4:  MOVWF  2C
....................  
....................     distanceDelante = (duration / 58); 
00A5:  MOVF   2C,W
00A6:  MOVWF  37
00A7:  MOVF   2B,W
00A8:  MOVWF  36
00A9:  CLRF   39
00AA:  MOVLW  3A
00AB:  MOVWF  38
00AC:  CALL   047
00AD:  MOVF   79,W
00AE:  MOVWF  31
00AF:  MOVF   78,W
00B0:  MOVWF  30
00B1:  BCF    0A.3
00B2:  BCF    0A.4
00B3:  GOTO   323 (RETURN)
.................... } 
....................  
.................... void sr04distDerecha() { 
....................     output_low(TRIGDER); 
00B4:  BCF    20.2
00B5:  MOVF   20,W
00B6:  BSF    03.5
00B7:  MOVWF  07
00B8:  BCF    03.5
00B9:  BCF    07.2
....................     delay_us(2); 
00BA:  GOTO   0BB
....................     output_high(TRIGDER); 
00BB:  BCF    20.2
00BC:  MOVF   20,W
00BD:  BSF    03.5
00BE:  MOVWF  07
00BF:  BCF    03.5
00C0:  BSF    07.2
....................     delay_us(10); 
00C1:  MOVLW  02
00C2:  MOVWF  77
00C3:  DECFSZ 77,F
00C4:  GOTO   0C3
00C5:  GOTO   0C6
00C6:  NOP
....................     output_low(TRIGDER); 
00C7:  BCF    20.2
00C8:  MOVF   20,W
00C9:  BSF    03.5
00CA:  MOVWF  07
00CB:  BCF    03.5
00CC:  BCF    07.2
....................  
....................     while (!input(ECHODER)); 
00CD:  BSF    20.3
00CE:  MOVF   20,W
00CF:  BSF    03.5
00D0:  MOVWF  07
00D1:  BCF    03.5
00D2:  BTFSS  07.3
00D3:  GOTO   0CD
....................     set_timer1(0); 
00D4:  CLRF   0E
00D5:  CLRF   0F
00D6:  CLRF   0E
....................     while (input(ECHODER)); 
00D7:  BSF    20.3
00D8:  MOVF   20,W
00D9:  BSF    03.5
00DA:  MOVWF  07
00DB:  BCF    03.5
00DC:  BTFSC  07.3
00DD:  GOTO   0D7
....................     duration = get_timer1(); 
00DE:  MOVF   0F,W
00DF:  MOVWF  7A
00E0:  MOVF   0E,W
00E1:  MOVWF  77
00E2:  MOVF   0F,W
00E3:  SUBWF  7A,W
00E4:  BTFSS  03.2
00E5:  GOTO   0DE
00E6:  MOVF   77,W
00E7:  MOVWF  2B
00E8:  MOVF   7A,W
00E9:  MOVWF  2C
....................  
....................     distanceDerecha = (duration / 58); 
00EA:  MOVF   2C,W
00EB:  MOVWF  37
00EC:  MOVF   2B,W
00ED:  MOVWF  36
00EE:  CLRF   39
00EF:  MOVLW  3A
00F0:  MOVWF  38
00F1:  CALL   047
00F2:  MOVF   79,W
00F3:  MOVWF  33
00F4:  MOVF   78,W
00F5:  MOVWF  32
00F6:  BCF    0A.3
00F7:  BCF    0A.4
00F8:  GOTO   324 (RETURN)
.................... } 
....................  
.................... void sr04distIzquierda() { 
....................     output_low(TRIGIZQ); 
00F9:  BCF    20.4
00FA:  MOVF   20,W
00FB:  BSF    03.5
00FC:  MOVWF  07
00FD:  BCF    03.5
00FE:  BCF    07.4
....................     delay_us(2); 
00FF:  GOTO   100
....................     output_high(TRIGIZQ); 
0100:  BCF    20.4
0101:  MOVF   20,W
0102:  BSF    03.5
0103:  MOVWF  07
0104:  BCF    03.5
0105:  BSF    07.4
....................     delay_us(10); 
0106:  MOVLW  02
0107:  MOVWF  77
0108:  DECFSZ 77,F
0109:  GOTO   108
010A:  GOTO   10B
010B:  NOP
....................     output_low(TRIGIZQ); 
010C:  BCF    20.4
010D:  MOVF   20,W
010E:  BSF    03.5
010F:  MOVWF  07
0110:  BCF    03.5
0111:  BCF    07.4
....................      
....................     set_timer1(0); 
0112:  CLRF   0E
0113:  CLRF   0F
0114:  CLRF   0E
....................     while (!input(ECHOIZQ)); 
0115:  BSF    20.5
0116:  MOVF   20,W
0117:  BSF    03.5
0118:  MOVWF  07
0119:  BCF    03.5
011A:  BTFSS  07.5
011B:  GOTO   115
....................     set_timer1(0); 
011C:  CLRF   0E
011D:  CLRF   0F
011E:  CLRF   0E
....................     while (input(ECHOIZQ)); 
011F:  BSF    20.5
0120:  MOVF   20,W
0121:  BSF    03.5
0122:  MOVWF  07
0123:  BCF    03.5
0124:  BTFSC  07.5
0125:  GOTO   11F
....................     duration = get_timer1(); 
0126:  MOVF   0F,W
0127:  MOVWF  7A
0128:  MOVF   0E,W
0129:  MOVWF  77
012A:  MOVF   0F,W
012B:  SUBWF  7A,W
012C:  BTFSS  03.2
012D:  GOTO   126
012E:  MOVF   77,W
012F:  MOVWF  2B
0130:  MOVF   7A,W
0131:  MOVWF  2C
....................     distanceIzquierda = (duration / 58); 
0132:  MOVF   2C,W
0133:  MOVWF  37
0134:  MOVF   2B,W
0135:  MOVWF  36
0136:  CLRF   39
0137:  MOVLW  3A
0138:  MOVWF  38
0139:  CALL   047
013A:  MOVF   79,W
013B:  MOVWF  35
013C:  MOVF   78,W
013D:  MOVWF  34
013E:  BCF    0A.3
013F:  BCF    0A.4
0140:  GOTO   325 (RETURN)
.................... } 
....................  
.................... void posicion() { 
....................     posA = 0; 
0141:  CLRF   27
....................     posB = 0; 
0142:  CLRF   28
....................     if (input(PIN_B4)) { 
0143:  BSF    03.5
0144:  BSF    06.4
0145:  BCF    03.5
0146:  BTFSS  06.4
0147:  GOTO   14B
....................         posA = 'W'; 
0148:  MOVLW  57
0149:  MOVWF  27
....................     } else if (input(PIN_B5)) { 
014A:  GOTO   152
014B:  BSF    03.5
014C:  BSF    06.5
014D:  BCF    03.5
014E:  BTFSS  06.5
014F:  GOTO   152
....................         posA = 'S'; 
0150:  MOVLW  53
0151:  MOVWF  27
....................     } 
....................     if (input(PIN_B6)) { 
0152:  BSF    03.5
0153:  BSF    06.6
0154:  BCF    03.5
0155:  BTFSS  06.6
0156:  GOTO   15A
....................         posB = 'D'; 
0157:  MOVLW  44
0158:  MOVWF  28
....................     } else if (input(PIN_B7)) { 
0159:  GOTO   161
015A:  BSF    03.5
015B:  BSF    06.7
015C:  BCF    03.5
015D:  BTFSS  06.7
015E:  GOTO   161
....................         posB = 'A'; 
015F:  MOVLW  41
0160:  MOVWF  28
....................     } 
0161:  BCF    0A.3
0162:  BCF    0A.4
0163:  GOTO   326 (RETURN)
.................... } 
....................  
.................... void main() { 
*
02E8:  MOVF   03,W
02E9:  ANDLW  1F
02EA:  MOVWF  03
02EB:  MOVLW  61
02EC:  BSF    03.5
02ED:  MOVWF  0F
02EE:  MOVF   0F,W
02EF:  BSF    03.6
02F0:  BCF    07.3
02F1:  MOVLW  19
02F2:  BCF    03.6
02F3:  MOVWF  19
02F4:  MOVLW  A6
02F5:  MOVWF  18
02F6:  MOVLW  90
02F7:  BCF    03.5
02F8:  MOVWF  18
02F9:  MOVLW  FF
02FA:  MOVWF  20
02FB:  CLRF   2A
02FC:  MOVLW  04
02FD:  MOVWF  2E
02FE:  MOVLW  4C
02FF:  MOVWF  2D
0300:  BSF    2F.0
0301:  BSF    03.5
0302:  BSF    03.6
0303:  MOVF   09,W
0304:  ANDLW  C0
0305:  MOVWF  09
0306:  BCF    03.6
0307:  BCF    1F.4
0308:  BCF    1F.5
0309:  MOVLW  00
030A:  BSF    03.6
030B:  MOVWF  08
030C:  BCF    03.5
030D:  CLRF   07
030E:  CLRF   08
030F:  CLRF   09
0310:  BCF    03.7
....................     stop(); 
*
0314:  CALL   036
....................     enable_interrupts(INT_TIMER0); 
0315:  BSF    0B.5
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256); 
0316:  BSF    03.5
0317:  MOVF   01,W
0318:  ANDLW  C0
0319:  IORLW  07
031A:  MOVWF  01
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_1); 
031B:  MOVLW  05
031C:  BCF    03.5
031D:  MOVWF  10
....................     set_timer1(0); 
031E:  CLRF   0E
031F:  CLRF   0F
0320:  CLRF   0E
....................     set_timer0(0); 
0321:  CLRF   01
....................  
....................     while (TRUE) { 
....................         sr04distDelante(); 
0322:  GOTO   06C
....................         sr04distDerecha(); 
0323:  GOTO   0B4
....................         sr04distIzquierda(); 
0324:  GOTO   0F9
....................         posicion(); 
0325:  GOTO   141
....................         valor = posA; 
0326:  MOVF   27,W
0327:  MOVWF  29
....................  
....................         if (posA == 'W') { 
0328:  MOVF   27,W
0329:  SUBLW  57
032A:  BTFSS  03.2
032B:  GOTO   337
....................             if (distanceDelante > 5) { 
032C:  MOVF   31,F
032D:  BTFSS  03.2
032E:  GOTO   333
032F:  MOVF   30,W
0330:  SUBLW  05
0331:  BTFSC  03.0
0332:  GOTO   336
....................                 valor = posA; 
0333:  MOVF   27,W
0334:  MOVWF  29
....................             } else { 
0335:  GOTO   337
....................                 valor = 0; 
0336:  CLRF   29
....................             } 
....................         } 
....................         if (posA == 'S') { 
0337:  MOVF   27,W
0338:  SUBLW  53
0339:  BTFSS  03.2
033A:  GOTO   341
....................             turns = back; 
033B:  MOVLW  08
033C:  MOVWF  2E
033D:  MOVLW  98
033E:  MOVWF  2D
....................             valor = 'D'; 
033F:  MOVLW  44
0340:  MOVWF  29
....................         } 
....................         if (posB == 'D') { 
0341:  MOVF   28,W
0342:  SUBLW  44
0343:  BTFSS  03.2
0344:  GOTO   367
....................             if (distanceDerecha > 5 && (distanceDelante <= 5 || posA != 'W')) { 
0345:  MOVF   33,F
0346:  BTFSS  03.2
0347:  GOTO   34C
0348:  MOVF   32,W
0349:  SUBLW  05
034A:  BTFSC  03.0
034B:  GOTO   35E
034C:  MOVF   31,F
034D:  BTFSS  03.2
034E:  GOTO   353
034F:  MOVF   30,W
0350:  SUBLW  05
0351:  BTFSC  03.0
0352:  GOTO   357
0353:  MOVF   27,W
0354:  SUBLW  57
0355:  BTFSC  03.2
0356:  GOTO   35E
....................                 turns = turn; 
0357:  MOVLW  04
0358:  MOVWF  2E
0359:  MOVLW  4C
035A:  MOVWF  2D
....................                 valor = posB; 
035B:  MOVF   28,W
035C:  MOVWF  29
....................             } else if (distanceDerecha < 5) { 
035D:  GOTO   367
035E:  MOVF   33,F
035F:  BTFSS  03.2
0360:  GOTO   367
0361:  MOVF   32,W
0362:  SUBLW  04
0363:  BTFSS  03.0
0364:  GOTO   367
....................                 posB = 'A'; 
0365:  MOVLW  41
0366:  MOVWF  28
....................             } 
....................         } 
....................         if (posB == 'A') { 
0367:  MOVF   28,W
0368:  SUBLW  41
0369:  BTFSS  03.2
036A:  GOTO   383
....................             if (distanceIzquierda > 5 && (distanceDelante <= 5 || posA != 'W')) { 
036B:  MOVF   35,F
036C:  BTFSS  03.2
036D:  GOTO   372
036E:  MOVF   34,W
036F:  SUBLW  05
0370:  BTFSC  03.0
0371:  GOTO   383
0372:  MOVF   31,F
0373:  BTFSS  03.2
0374:  GOTO   379
0375:  MOVF   30,W
0376:  SUBLW  05
0377:  BTFSC  03.0
0378:  GOTO   37D
0379:  MOVF   27,W
037A:  SUBLW  57
037B:  BTFSC  03.2
037C:  GOTO   383
....................                 turns = turn; 
037D:  MOVLW  04
037E:  MOVWF  2E
037F:  MOVLW  4C
0380:  MOVWF  2D
....................                 valor = posB; 
0381:  MOVF   28,W
0382:  MOVWF  29
....................             } 
....................         } 
....................         if (distanceDelante <= 5 && distanceDerecha <= 5 && distanceIzquierda <= 5) { 
0383:  MOVF   31,F
0384:  BTFSS  03.2
0385:  GOTO   39C
0386:  MOVF   30,W
0387:  SUBLW  05
0388:  BTFSS  03.0
0389:  GOTO   39C
038A:  MOVF   33,F
038B:  BTFSS  03.2
038C:  GOTO   39C
038D:  MOVF   32,W
038E:  SUBLW  05
038F:  BTFSS  03.0
0390:  GOTO   39C
0391:  MOVF   35,F
0392:  BTFSS  03.2
0393:  GOTO   39C
0394:  MOVF   34,W
0395:  SUBLW  05
0396:  BTFSS  03.0
0397:  GOTO   39C
....................             valor = 'D'; 
0398:  MOVLW  44
0399:  MOVWF  29
....................             posA = 'S'; 
039A:  MOVLW  53
039B:  MOVWF  27
....................         } 
....................         if (valor == 0) { 
039C:  MOVF   29,F
039D:  BTFSC  03.2
....................             testprintf = 1; 
039E:  BSF    2F.0
....................         } 
....................         action(); 
039F:  GOTO   1D1
....................         if (get_timer0() >= 196) { 
03A0:  MOVF   01,W
03A1:  SUBLW  C3
03A2:  BTFSC  03.0
03A3:  GOTO   3A6
....................             set_timer0(0); 
03A4:  CLRF   01
....................             check++; 
03A5:  INCF   2A,F
....................         } 
....................         if (check > 2) { 
03A6:  MOVF   2A,W
03A7:  SUBLW  02
03A8:  BTFSC  03.0
03A9:  GOTO   3FC
....................             check = 0; 
03AA:  CLRF   2A
....................             printf("\nAdelante: %lu cm\n", distanceDelante); 
03AB:  MOVLW  18
03AC:  BSF    03.6
03AD:  MOVWF  0D
03AE:  MOVLW  00
03AF:  MOVWF  0F
03B0:  BCF    03.0
03B1:  MOVLW  0B
03B2:  BCF    03.6
03B3:  MOVWF  36
03B4:  CALL   236
03B5:  MOVLW  10
03B6:  MOVWF  04
03B7:  MOVF   31,W
03B8:  MOVWF  37
03B9:  MOVF   30,W
03BA:  MOVWF  36
03BB:  CALL   28F
03BC:  MOVLW  1F
03BD:  BSF    03.6
03BE:  MOVWF  0D
03BF:  MOVLW  00
03C0:  MOVWF  0F
03C1:  BCF    03.0
03C2:  MOVLW  04
03C3:  BCF    03.6
03C4:  MOVWF  36
03C5:  CALL   236
....................             printf("\nDerecha: %lu cm\n", distanceDerecha); 
03C6:  MOVLW  22
03C7:  BSF    03.6
03C8:  MOVWF  0D
03C9:  MOVLW  00
03CA:  MOVWF  0F
03CB:  BCF    03.0
03CC:  MOVLW  0A
03CD:  BCF    03.6
03CE:  MOVWF  36
03CF:  CALL   236
03D0:  MOVLW  10
03D1:  MOVWF  04
03D2:  MOVF   33,W
03D3:  MOVWF  37
03D4:  MOVF   32,W
03D5:  MOVWF  36
03D6:  CALL   28F
03D7:  MOVLW  28
03D8:  BSF    03.6
03D9:  MOVWF  0D
03DA:  MOVLW  00
03DB:  MOVWF  0F
03DC:  BSF    03.0
03DD:  MOVLW  04
03DE:  BCF    03.6
03DF:  MOVWF  36
03E0:  CALL   236
....................             printf("\nIzquierda: %lu cm\n\n\n", distanceIzquierda); 
03E1:  MOVLW  2B
03E2:  BSF    03.6
03E3:  MOVWF  0D
03E4:  MOVLW  00
03E5:  MOVWF  0F
03E6:  BCF    03.0
03E7:  MOVLW  0C
03E8:  BCF    03.6
03E9:  MOVWF  36
03EA:  CALL   236
03EB:  MOVLW  10
03EC:  MOVWF  04
03ED:  MOVF   35,W
03EE:  MOVWF  37
03EF:  MOVF   34,W
03F0:  MOVWF  36
03F1:  CALL   28F
03F2:  MOVLW  32
03F3:  BSF    03.6
03F4:  MOVWF  0D
03F5:  MOVLW  00
03F6:  MOVWF  0F
03F7:  BSF    03.0
03F8:  MOVLW  06
03F9:  BCF    03.6
03FA:  MOVWF  36
03FB:  CALL   236
....................         } 
03FC:  GOTO   322
....................     } 
.................... } 
03FD:  SLEEP

Configuration Fuses:
   Word  1: 2FE4   INTRC_IO NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
